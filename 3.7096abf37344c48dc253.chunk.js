webpackJsonp([3],{fZvo:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=t("LMZF"),o=[{name:"combineAll",operatorType:"combination",signature:"public combineAll(project: function): Observable",parameters:[{name:"project",type:"function",attribute:"optional",description:"An optional function to map the most recent values from each inner Observable into a new result.\n      Takes each of the most recent values from each collected inner Observable as arguments, in order."}],marbleUrl:"http://reactivex.io/rxjs/img/combineAll.png",shortDescription:{description:'\n      Flattens an Observable-of-Observables by applying <a href="/#/operators/combineLatest" class="markdown-code">combineLatest</a>\n      when the Observable-of-Observables completes.',extras:[]},walkthrough:{description:'\n      <p>\n        Takes an Observable of Observables, and collects all Observables from it.\n        Once the outer Observable completes, it subscribes to all collected\n        Observables and combines their values using the <a href="/#/operators/combineLatest" class="markdown-code">combineLatest</a>\n        strategy, such that:\n      </p>\n      <ul>\n        <li>Every time an inner Observable emits, the output Observable emits.</li>\n        <li>When the returned observable emits, it emits all of the latest values by:\n          <ul>\n            <li>\n              If a <span class="markdown-code">project</span> function is provided, it is called with each recent value\n              from each inner Observable in whatever order they arrived, and the result\n              of the <span class="markdown-code">project</span> function is what is emitted by the output Observable.\n            </li>\n            <li>\n              If there is no <span class="markdown-code">project</span> function, an array of all of the most recent\n              values is emitted by the output Observable.\n            </li>\n          </ul>\n        </li>\n      </ul>\n    '},examples:[{name:'Map two click events to a finite interval Observable, then apply <span class="markdown-code">combineAll</span>',code:"\n        import { map, combineAll, take } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const higherOrder = clicks.pipe(\n          map(ev =>\n            interval(Math.random()*2000).pipe(take(3))\n          ),\n          take(2)\n        );\n        const result = higherOrder.pipe(\n          combineAll()\n        );\n        result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/peparawuvo/1/embed?js,console,output"}}],relatedOperators:["combineLatest","mergeAll"],additionalResources:[]},{name:"combineLatest",operatorType:"combination",signature:"public combineLatest(observables: ...Observable, project: function): Observable",useInteractiveMarbles:!0,parameters:[{name:"other",type:"Observable",attribute:"",description:"An input Observable to combine with the source Observable. More than one input Observables may be given as argument."},{name:"other",type:"function",attribute:"optional",description:"An optional function to project the values from the combined latest values into a new value on the output Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/combineLatest.png",shortDescription:{description:"\n      Combines multiple Observables to create an Observable whose values\n      are calculated from the latest values of each of its input Observables.\n    ",extras:[{type:"Tip",text:'\n          Note: combineLatest will only start to emit when all sources have emitted at least once. By adding a default\n           start value to the sources with <a href="#/operators/startWith" class="markdown-code">startWith</a>, it will activate right away.\n         '}]},walkthrough:{description:'\n      <p>\n        <span class="markdown-code">combineLatest</span> combines the values from this Observable with values from\n        Observables passed as arguments. This is done by subscribing to each\n        Observable, in order, and collecting an array of each of the most recent\n        values any time any of the input Observables emits, then either taking that\n        array and passing it as arguments to an optional <span class="markdown-code">project</span> function and\n        emitting the return value of that, or just emitting the array of recent\n        values directly if there is no <span class="markdown-code">project</span> function.\n      </p>\n    '},examples:[{name:"Dynamically calculate the Body-Mass Index from an Observable of weight and one for height",code:"\n        import { combineLatest } from 'rxjs/operators;\n        import { of } from 'rxjs/observable/of';\n\n        const weight = of(70, 72, 76, 79, 75);\n        const height = of(1.76, 1.77, 1.78);\n        const bmi = weight.pipe(\n          combineLatest(height, (w, h) => w / (h * h))\n        );\n        /*\n           Output:\n           BMI is 24.212293388429753\n           BMI is 23.93948099205209\n           BMI is 23.671253629592222\n        */\n        bmi.subscribe(x => console.log('BMI is ' + x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/pivowunedu/1/embed?js,console"}}],relatedOperators:["combineAll","merge","withLatestFrom"],additionalResources:[]},{name:"concat",operatorType:"combination",signature:"public static concat(input1: ObservableInput, input2: ObservableInput, scheduler: Scheduler): Observable",parameters:[{name:"input1",type:"ObservableInput",attribute:"",description:"An input Observable to concatenate with others."},{name:"input2",type:"ObservableInput",attribute:"",description:"An input Observable to concatenate with others. More than one input Observables may be given as argument."},{name:"scheduler",type:"Scheduler",attribute:"optional default: null",description:"An optional IScheduler to schedule each Observable subscription on."}],marbleUrl:"http://reactivex.io/rxjs/img/concat.png",shortDescription:{description:"Creates an output Observable which sequentially emits all values from given Observable and then moves on to the next.",extras:[{type:"Tip",text:"Concatenates multiple Observables together by sequentially emitting their values, one Observable after the other."}]},walkthrough:{description:"\n      <p><span class='markdown-code'>concat</span> joins multiple Observables together, by subscribing to them one at a time and\n      merging their results into the output Observable. You can pass either an array of\n      Observables, or put them directly as arguments. Passing an empty array will result\n      in Observable that completes immediately.</p>\n\n      <p><span class='markdown-code'>concat</span> will subscribe to first input Observable and emit all its values, without\n      changing or affecting them in any way. When that Observable completes, it will\n      subscribe to then next Observable passed and, again, emit its values. This will be\n      repeated, until the operator runs out of Observables. When last input Observable completes,\n      <span class='markdown-code'>concat</span> will complete as well. At any given moment only one Observable passed to operator\n      emits values. If you would like to emit values from passed Observables concurrently, check out\n      <a href='/#/operators/merge' class='markdown-code'>merge</a> instead, especially with optional\n      <span class='markdown-code'>concurrent</span> parameter.\n      As a matter of fact, <span class='markdown-code'>concat</span> is an equivalent of\n      <a href='/#/operators/merge' class='markdown-code'>merge</a> operator with\n      <span class='markdown-code'>concurrent</span> parameter set to <span class='markdown-code'>1</span>.</p>\n\n      <p>Note that if some input Observable never completes, <span class='markdown-code'>concat</span> will also never complete\n      and Observables following the one that did not complete will never be subscribed. On the other\n      hand, if some Observable simply completes immediately after it is subscribed, it will be\n      invisible for <span class='markdown-code'>concat</span>, which will just move on to the next Observable.</p>\n\n      <p>If any Observable in chain errors, instead of passing control to the next Observable,\n      <span class='markdown-code'>concat</span> will error immediately as well. Observables that would be subscribed after\n      the one that emitted error, never will.</p>\n\n      <p>If you pass to <span class='markdown-code'>concat</span> the same Observable many times, its stream of values\n      will be 'replayed' on every subscription, which means you can repeat given Observable\n      as many times as you like. If passing the same Observable to <span class='markdown-code'>concat</span> 1000 times becomes tedious,\n      you can always use <span class='markdown-code'>repeat</span>.</p>\n    "},examples:[{name:"Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10",code:"\n      import { take } from 'rxjs/operators';\n      import { interval } from 'rxjs/observable/interval';\n      import { range } from 'rxjs/observable/range';\n      import { concat } from 'rxjs/observable/concat';\n\n      const timer = interval(1000).pipe(take(4));\n      const sequence = range(1, 10);\n      const result = concat(timer, sequence);\n      result.subscribe(x => console.log(x));\n\n      // results in:\n      // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/doqoyimaxu/embed?js,console"}},{name:"Concatenate an array of 3 Observables",code:"\n      import { take, concat } from 'rxjs/operators';\n      import { interval } from 'rxjs/observable/interval';\n\n      const timer1 = interval(1000).pipe(take(10));\n      const timer2 = interval(2000).pipe(take(6));\n      const timer3 = interval(500).pipe(take(10));\n      const result = timer1.pipe(concat(timer2, timer3));\n      result.subscribe(x => console.log(x));\n\n      // results in the following:\n      // (Prints to console sequentially)\n      // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n      // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n      // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/decaromone/1/embed?js,console"}}],relatedOperators:["concatAll","concatMap","concatMapTo"]},{name:"concatAll",operatorType:"combination",signature:"public concatAll(): Observable",parameters:[],marbleUrl:"http://reactivex.io/rxjs/img/concatAll.png",shortDescription:{description:"Converts a higher-order Observable into a first-order Observable by concatenating the inner Observables in order.",extras:[{type:"Tip",text:"Flattens an Observable-of-Observables by putting one inner Observable after the other."}]},walkthrough:{description:"\n      Joins every Observable emitted by the source (a higher-order Observable), in a serial fashion.\n      It subscribes to each inner Observable only after the previous inner Observable has completed,\n      and merges all of their values into the returned observable.\n    ",extras:[{type:"Warning",text:"\n        If the source Observable emits Observables quickly and endlessly, and the inner Observables it emits generally\n        complete slower than the source emits, you can run into memory issues as the incoming Observables collect in an unbounded buffer.\n      "},{type:"Tip",text:"concatAll is equivalent to mergeAll with concurrency parameter set to 1."}]},examples:[{name:"For each click event, tick every second from 0 to 3, with no concurrency",code:"\n        import { map, take, concatAll } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const higherOrder = clicks.pipe(\n          map(ev => interval(1000).pipe(take(4)))\n        );\n        const firstOrder = higherOrder.pipe(concatAll());\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/guhefeyahi/embed?js,console,output"}}],relatedOperators:["combineAll","concat","concatMap","concatMapTo","exhaust","mergeAll","switch","zipAll"],additionalResources:[]},{name:"forkJoin",operatorType:"combination",signature:"public static forkJoin(sources: *): any",parameters:[{name:"sources",type:"*",attribute:"",description:""}],marbleUrl:"http://reactivex.io/rxjs/img/forkJoin.png",shortDescription:{description:"Joins last values emitted by passed Observables.",extras:[{type:"Tip",text:"Wait for Observables to complete and then combine last values they emitted."}]},walkthrough:{description:'\n      <p>\n        <span class="markdown-code">forkJoin</span> is an operator that takes any number of\n        Observables which can be passed either as an array or directly as arguments. If no input\n        Observables are provided, resulting stream will complete immediately.\n      </p>\n      <p>\n        <span class="markdown-code">forkJoin</span> will wait for all passed Observables to complete\n        and then it will emit an array with last values from corresponding Observables. So if you\n        pass "n" Observables to the operator, resulting array will have "n" values, where first\n        value is the last thing emitted by the first Observable, second value is the last thing\n        emitted by the second Observable and so on. That means <span class="markdown-code">forkJoin</span> will\n        not emit more than once and it will complete after that. If you need to emit combined values not only\n        at the end of lifecycle of passed Observables, but also throughout it, try out\n        <a href=\'/#/operators/combineLatest\' class=\'markdown-code\'>combineLatest</a>\n        or <a href=\'/#/operators/zip\' class=\'markdown-code\'>zip</a> instead.\n      </p>\n      <p>\n        In order for resulting array to have the same length as the number of input Observables, whenever any of that\n        Observables completes without emitting any value,\n        <span class="markdown-code">forkJoin</span> will complete at that moment as well and it will not\n        emit anything either, even if it already has some last values from other Observables.\n      </p>\n\n      <p>\n        Conversely, if there is an Observable that never completes,\n        <span class="markdown-code">forkJoin</span> will never complete as well, unless at\n        any point some other Observable completes without emitting value, which brings us back to the previous case.\n        Overall, in order for <span class="markdown-code">forkJoin</span> to emit a value, all Observables passed as arguments\n        have to emit something at least once and complete.\n      </p>\n      <p>\n        If any input Observable errors at some point, <span class="markdown-code">forkJoin</span>\n        will error as well and all other Observables\n        will be immediately unsubscribed.\n      </p>\n      <p>\n        Optionally <span class="markdown-code">forkJoin</span> accepts project function, that will be\n        called with values which normally would land in emitted array. Whatever is returned by project function,\n        will appear in output Observable instead. This means that default project can be thought of as a\n        function that takes all its arguments and puts them into an array. Note that project function will be called only\n        when output Observable is supposed to emit a result.\n      </p>\n    '},examples:[{name:"Use forkJoin with operator emitting immediately",code:"\n      import { forkJoin } from 'rxjs/observable/forkJoin';\n      import { of } from 'rxjs/observable/of';\n\n      const observable = forkJoin(\n        of(1, 2, 3, 4),\n        of(5, 6, 7, 8)\n      );\n      observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log('This is how it ends!')\n      );\n      // Logs:\n      // [4, 8]\n      // \"This is how it ends!\"\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/kinilaruki/1/embed?js,console"}},{name:"Use forkJoin with operator emitting after some time",code:"\n      import { take } from 'rxjs/operators';\n      import { forkJoin } from 'rxjs/observable/forkJoin';\n      import { interval } from 'rxjs/observable/interval';\n\n      const observable = forkJoin(\n        interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete\n        interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete\n      );\n      observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log('This is how it ends!')\n      );\n      // Logs:\n      // [2, 3] after 3 seconds\n      // \"This is how it ends!\" immediately after\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/rewivubuqi/1/embed?js,console"}},{name:"Use forkJoin with project function",code:"\n      const observable = Rx.Observable.forkJoin(\n        Rx.Observable.interval(1000).take(3), // emit 0, 1, 2 every second and complete\n        Rx.Observable.interval(500).take(4), // emit 0, 1, 2, 3 every half a second and complete\n        (n, m) => n + m\n      );\n      observable.subscribe(\n        value => console.log(value),\n        err => {},\n        () => console.log('This is how it ends!')\n      );\n      // Logs:\n      // 5 after 3 seconds\n      // \"This is how it ends!\" immediately after\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wayomumike/1/embed?js,console"}}],relatedOperators:["combineLatest","zip"]},{name:"merge",operatorType:"combination",signature:"public merge(other: ObservableInput, concurrent: number, scheduler: Scheduler): Observable",parameters:[{name:"other",type:"ObservableInput",attribute:"",description:"An input Observable to merge with the source Observable. More than one input\n       Observables may be given as argument."},{name:"concurrent",type:"number",attribute:"optional, default: Number.POSITIVE_INFINITY",description:"Maximum number of input Observables being subscribed to concurrently."},{name:"scheduler",type:"Scheduler",attribute:"optional, default: null",description:"The IScheduler to use for managing concurrency of input Observables."}],marbleUrl:"http://reactivex.io/rxjs/img/merge.png",shortDescription:{description:'Creates an output Observable which concurrently emits all values\n      from every given input Observable. <span class="informal">Flattens multiple Observables\n      together by blending their values into one Observable.</span>'},walkthrough:{description:'\n      <p><span class="markdown-code">Merge</span> subscribes to each given input Observable (either the source or an\n      Observable given as argument), and simply forwards (without doing any\n      transformation) all the values from all the input Observables to the output\n      Observable. The output Observable only completes once all input Observables\n      have completed. Any error delivered by an input Observable will be immediately\n      emitted on the output Observable.</p>\n    '},examples:[{name:"Merge together two Observables: 1s interval and clicks",code:"\n        import { merge } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const timer = interval(1000);\n        const clicksOrTimer = clicks.pipe(merge(timer));\n        clicksOrTimer.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wihafapiva/1/embed?js,output"}},{name:"Merge together 3 Observables, but only 2 run concurrently",code:"\n        import { take } from 'rxjs/operators';\n        import { merge } from 'rxjs/observable/merge';\n        import { interval } from 'rxjs/observable/interval';\n\n        const timer1 = interval(1000).pipe(take(10));\n        const timer2 = interval(2000).pipe(take(6));\n        const timer3 = interval(500).pipe(take(10));\n        const concurrent = 2; // the argument\n        const merged = timer1.pipe(merge(timer2, timer3, concurrent));\n        merged.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/midosuqaga/1/embed?js,output"}}],relatedOperators:["mergeAll","mergeMap","mergeMapTo","mergeScan"]},{name:"mergeAll",operatorType:"combination",signature:"public mergeAll(concurrent: number): Observable",parameters:[{name:"concurrent",type:"number",attribute:"optional, default: Number.POSITIVE_INFINITY",description:"Maximum number of input Observables being subscribed to concurrently."}],marbleUrl:"http://reactivex.io/rxjs/img/mergeAll.png",shortDescription:{description:"Converts a higher-order Observable into a first-order Observable which concurrently\n     delivers all values that are emitted on the inner Observables",extras:[{type:"Tip",text:"Flattens an Observable-of-Observables."}]},walkthrough:{description:'\n      <p><span class="markdown-code">MergeAll</span> subscribes to an Observable that emits Observables,\n        also known as a higher-order Observable. Each time it observes one of these emitted\n        inner Observables, it subscribes to that and delivers all the values from the inner\n        Observable on the output Observable. The output Observable only completes once all inner\n        Observables have completed. Any error delivered by a inner Observable will be immediately\n        emitted on the output Observable.</p>\n    '},examples:[{name:"Spawn a new interval Observable for each click event, and blend their outputs as one Observable",code:"\n        import { mergeAll, map } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const higherOrder = clicks.pipe(map((ev) => interval(1000)));\n        const firstOrder = higherOrder.pipe(mergeAll());\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/lebidefocu/1/embed?js,output"}},{name:"Count from 0 to 9 every second for each click, but only allow 2 concurrent timers",code:"\n        import { mergeAll, map } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const higherOrder = clicks.pipe(\n          map((ev) => interval(1000).pipe(take(10)))\n        );\n        const firstOrder = higherOrder.pipe(mergeAll(2));\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/kokezoribu/embed?js,output"}}],relatedOperators:["combineAll","concatAll","exhaust","merge","mergeMap","mergeMapTo","mergeScan","switch","zipAll"]},{name:"pairwise",operatorType:"combination",marbleUrl:"http://reactivex.io/rxjs/img/pairwise.png",signature:"public pairwise(): Observable<Array<T>>",shortDescription:{description:"Groups pairs of consecutive emissions together and emits them as an array of two values.",extras:[{type:"Tip",text:"Puts the current value and previous value together as an array, and emits that."}]},walkthrough:{description:"\n      <p>The Nth emission from the source Observable will cause the output Observable\n      to emit an array [(N-1)th, Nth] of the previous and the current value, as a\n      pair. For this reason, <code>pairwise</code> emits on the second and subsequent\n      emissions from the source Observable, but not on the first emission, because\n      there is no previous value in that case.</p>\n    "},examples:[{name:"On every click (starting from the second), emit the relative distance to the previous click",code:"\n      import { pairwise, map } from 'rxjs/operators';\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n\n      const clicks = fromEvent(document, 'click');\n      const pairs = clicks.pipe(pairwise());\n      const distance = pairs.pipe(\n        map(pair => {\n          const x0 = pair[0].clientX;\n          const y0 = pair[0].clientY;\n          const x1 = pair[1].clientX;\n          const y1 = pair[1].clientY;\n          return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n        })\n      );\n      distance.subscribe(x => console.log(x));\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wenazagegu/embed?js,console,output"}}],relatedOperators:["buffer","bufferCount"]},{name:"race",operatorType:"combination"},{name:"startWith",operatorType:"combination",marbleUrl:"http://reactivex.io/rxjs/img/startWith.png",signature:"public startWith(values: ...T, scheduler: Scheduler): Observable",shortDescription:{description:"Returns an Observable that emits the items you specify as arguments before it begins to emit items emitted by the source Observable."},parameters:[{name:"values",type:"...T",attribute:"",description:"Items you want the modified Observable to emit first."},{name:"scheduler",type:"Scheduler",attribute:"optional",description:"A IScheduler to use for scheduling the emissions of the next notifications."}]},{name:"withLatestFrom",operatorType:"combination",signature:"public withLatestFrom(other: ObservableInput, project: Function): Observable",marbleUrl:"http://reactivex.io/rxjs/img/withLatestFrom.png",shortDescription:{description:"Combines the source Observable with other Observables to create an Observable whose values are\n      calculated from the latest values of each, only when the source emits.",extras:[{type:"Tip",text:"Whenever the source Observable emits a value, it computes a formula using that\n      value plus the latest values from other input Observables, then emits the output of that formula."}]},walkthrough:{description:'\n        <p><span class="markdown-code">withLatestFrom</span> combines each value from the source Observable (the instance) with the latest\n        values from the other input Observables only when the source emits a value, optionally using\n        a project function to determine the value to be emitted on the output Observable. All input\n        Observables must emit at least one value before the output Observable will emit a value.\n        </p>\n      '},examples:[{name:"For each click event, tick every second from 0 to 3, with no concurrency",code:"\n        import { take, concatAll, map } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const higherOrder = clicks.pipe(\n          map(ev => interval(1000).pipe(take(4)))\n        );\n        const firstOrder = higherOrder.pipe(concatAll());\n        firstOrder.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wojoqenitu/1/embed?js,console,output"}}],relatedOperators:["combineLatest"]},{name:"zip",operatorType:"combination"}].concat([{name:"defaultIfEmpty",operatorType:"conditional"},{name:"every",operatorType:"conditional"}],[{name:"create",operatorType:"creation"},{name:"empty",operatorType:"creation",signature:"public empty(scheduler?: IScheduler): Observable",parameters:[{name:"scheduler",type:"IScheduler",attribute:"optional",description:"Allows scheduling the emission of the complete notification."}],marbleUrl:"http://reactivex.io/rxjs/img/empty.png",shortDescription:{description:"Creates an Observable that emits no items to the Observer and immediately emits a complete notification."},walkthrough:{description:"This static operator is useful for creating a simple\n       Observable that only emits the complete notification. It can be used for\n       composing with other Observables"},examples:[{name:"Observable completes immediately",code:"\n          import { empty } from 'rxjs/observable/empty';\n\n          const observable = empty();\n          const subscription = observable.subscribe({\n            next: () => console.log('next'), // does not log anything\n            complete: () => console.log('complete'), // logs 'complete'\n          });\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/hojacunecu/1/embed?js,console,output"}},{name:"Observable emits initial value then completes",code:"\n        import { startWith } from 'rxjs/operators';\n        import { empty } from 'rxjs/observable/empty';\n\n        const observable = empty().pipe(startWith('initial value'));\n        const subscription = observable.subscribe({\n          next: (val) => console.log(`next: ${val}`), // logs 'next: initial value'\n          complete: () => console.log('complete'), // logs 'complete'\n        });\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/tubonoradi/1/embed?js,console,output"}},{name:"Map and flatten only odd numbers to the sequence 'ax', 'bx', 'cx'",code:"\n        import { mergeMap } from 'rxjs/operators';\n        import { of } from 'rxjs/observable/of';\n        import { empty } from 'rxjs/observable/empty';\n\n        const source = of(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        const result = source.pipe(\n          mergeMap(\n            x => x % 2 === 1 ? of(`a${x}`, `b${x}`, `c${x}`) :\n                              empty()\n          )\n        );\n        const subscription = result.subscribe({\n          next: (x) => console.log(x), // logs result values\n          complete: () => console.log('complete'), // logs 'complete'\n        });\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/qazabojiri/embed?js,console,output"}}],relatedOperators:["create","of","throw"]},{name:"from",operatorType:"creation",signature:"from(ish: ArrayLike | ObservableInput, scheduler: Scheduler): Observable",parameters:[{name:"ish",type:"ArrayLike | ObservableInput",attribute:"",description:"A subscribable object, a Promise, an  Observable-like, an Array, an\n\t  iterable or an array-like object to be converted."},{name:"scheduler",type:"Scheduler",attribute:"optional",description:"The scheduler on which to schedule the emissions of values."}],marbleUrl:"http://reactivex.io/rxjs/img/from.png",shortDescription:{description:'Creates an Observable from an Array, an array-like object, a Promise, an\n    iterable object, or an Observable-like object.\n    <span class="informal">Converts almost anything to an Observable.</span>'},walkthrough:{description:"Converts various other objects and data types into Observables. <span class=\"markdown-code\">from</span>\n    converts a Promise or an array-like or an\n    <a href ='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable' target='_blank'>iterable</a>\n    object into an Observable that emits the items in that promise or array or\n    iterable. A String, in this context, is treated as an array of characters.\n    Observable-like objects (contains a function named with the ES2015 Symbol\n    for Observable) can also be converted through this operator.\n   "},examples:[{name:"Converts an array to an Observable",code:"\n      import { from } from 'rxjs/observable/from';\n\n      const array = [10, 20, 30];\n      const result = from(array);\n      result.subscribe(x => console.log(x));\n\n      // Results in the following:\n      // 10 20 30",externalLink:{platform:"JSBin",url:"http://jsbin.com/qodocay/embed?js,console"}},{name:"Convert an infinite iterable (from a generator) to an Observable",code:"\n      import { take } from 'rxjs/operators';\n      import { from } from 'rxjs/observable/from';\n\n      function* generateDoubles(seed) {\n        let i = seed;\n        while (true) {\n          yield i;\n          i = 2 * i; // double it\n        }\n      }\n      const iterator = generateDoubles(3);\n      const result = from(iterator).pipe(take(10));\n      result.subscribe(x => console.log(x));\n      // Results in the following:\n      // 3 6 12 24 48 96 192 384 768 1536",externalLink:{platform:"JSBin",url:"http://jsbin.com/kidevan/embed?js,console"}},{name:'Using <span class="markdown-code">from</span> with async scheduler',code:"\n      import { from } from 'rxjs/observable/from';\n      import { async } from 'rxjs/scheduler/async';\n\n      console.log('start');\n      const array = [10, 20, 30];\n      const result = from(array, async);\n      result.subscribe(x => console.log(x));\n      console.log('end');\n      // Results in the following:\n      // start end 10 20 30",externalLink:{platform:"JSBin",url:"http://jsbin.com/xunesam/embed?js,console"}}],relatedOperators:["create","fromEvent","fromEventPattern","fromPromise"]},{name:"fromEvent",operatorType:"creation"},{name:"fromPromise",operatorType:"creation"},{name:"interval",operatorType:"creation"},{name:"of",operatorType:"creation"},{name:"range",operatorType:"creation"},{name:"throw",operatorType:"creation"},{name:"timer",operatorType:"creation"}],[{name:"catch",operatorType:"error handling"},{name:"catch",operatorType:"error handling"},{name:"retryWhen",operatorType:"error handling"}],[{name:"debounce",operatorType:"filtering",signature:"public debounce(durationSelector: function(value: T): SubscribableOrPromise): Observable",marbleUrl:"http://reactivex.io/rxjs/img/debounce.png",parameters:[{name:"durationSelector",type:"function(value: T): SubscribableOrPromise",attribute:"",description:"A function that receives a value from the source Observable\n        , for computing the timeout duration for each source value, returned as an Observable or a Promise."}],shortDescription:{description:"Emits a value from the source Observable only after a particular time span determined\n       by another Observable has passed without another source emission.",extras:[{type:"Tip",text:"\n        It's like debounceTime, but the time span of emission silence is determined by a second Observable.\n        "}]},walkthrough:{description:"\n      <p>\n        debounce delays values emitted by the source Observable,\n        but drops previous pending delayed emissions if a new value arrives on the source Observable.\n        This operator keeps track of the most recent value from the source Observable,\n        and spawns a duration Observable by calling the durationSelector function.\n        The value is emitted only when the duration Observable emits a value or completes,\n        and if no other value was emitted on the source Observable since the duration Observable was spawned.\n        If a new value appears before the duration Observable emits,\n        the previous value will be dropped and will not be emitted on the output Observable.\n      </p>\n      <p>\n      Like debounceTime, this is a rate-limiting operator, and also a delay-like operator\n      since output emissions do not necessarily occur at the same time as they did on the source Observable.\n      </p>\n    "},examples:[{name:"Emit the most recent click after a burst of clicks",code:"\n        import { debounce } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const result = clicks.pipe(debounce(() => interval(1000)));\n        result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/zuyafikiqa/embed?js,console,output"}}],relatedOperators:["debounceTime","audit","delayWhen","throttle"],additionalResources:[]},{name:"debounceTime",operatorType:"filtering",signature:"public debounceTime(dueTime: number, scheduler: IScheduler = async): Observable",parameters:[{name:"dueTime",type:"number",attribute:"mandatory",description:"The timeout duration in milliseconds\n      (or the time unit determined internally by the optional scheduler) for the window of time required to\n      wait for emission silence before emitting the most recent source value."},{name:"scheduler",type:"IScheduler",attribute:"optional",description:"The IScheduler to use for managing the timers that handle the timeout for each value."}],marbleUrl:"http://reactivex.io/rxjs/img/debounceTime.png",shortDescription:{description:'\n    Emits a value from the source Observable only after a particular time span has passed without another source emission.\n    It\'s like <a class="markdown-code" href="#/operators/delay">delay</a>\n    , but passes only the most recent value from each burst of emissions.',extras:[]},walkthrough:{description:'\n      <p>\n      <span class="markdown-code">debounceTime</span> delays values emitted by the source Observable, but drops\n      previous pending delayed emissions if a new value arrives on the source\n      Observable. This operator keeps track of the most recent value from the\n      source Observable, and emits that only when <span class="markdown-code">dueTime</span> enough time has passed\n      without any other value appearing on the source Observable. If a new value\n      appears before <span class="markdown-code">dueTime</span> silence occurs, the previous value will be dropped\n      and will not be emitted on the output Observable.\n      </p>\n      <p>\n        This is a rate-limiting operator, because it is impossible for more than one\n        value to be emitted in any time window of duration <span class="markdown-code">dueTime</span>, but it is also\n        a delay-like operator since output emissions do not occur at the same time as\n        they did on the source Observable. Optionally takes a <span class="markdown-code">IScheduler</span> for\n        managing timers.\n      </p>\n    '},examples:[{name:"Emit the most recent value after a burst of value changes over a defined time",code:"\n        import { map, debounceTime } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const search = document.querySelector('#search');\n        const output = document.querySelector('#output');\n        const searchChange$ = fromEvent(search, 'keyup');\n\n        searchChange$.pipe(\n          map(x => x.target.value),\n          debounceTime(500)\n        )\n        .subscribe((search)=> output.textContent=search);\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/gapobakuwu/edit?js,output"}}],relatedOperators:["auditTime","debounce","delay","sampleTime","throttleTime"],additionalResources:[]},{name:"distinctUntilChanged",operatorType:"filtering",signature:"public distinctUntilChanged(compare: function): Observable",useInteractiveMarbles:!0,parameters:[{name:"compare",type:"function",attribute:"optional",description:"Optional comparison function called to test if an item is distinct from the previous item in the source."}],marbleUrl:"http://reactivex.io/rxjs/img/distinctUntilChanged.png",shortDescription:{description:"\n    Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.\n    ",extras:[{type:"Tip",text:'\n        <span class="markdown-code">distinctUntilChanged</span> uses\n        <a\n          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness"\n          target="_blank"\n          class="markdown-code">\n          ===\n        </a> comparison by default.\n       '}]},walkthrough:{description:"\n      <p>\n        This operator will compare each emitted item from the source to the previously emitted item,\n        emitting only distinct values by comparison such that:\n      </p>\n      <ul>\n        <li>\n         If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.\n        </li>\n        <li>\n          If a comparator function is not provided, an equality check is used by default.\n        </li>\n      </ul>\n    "},examples:[{name:"A simple example with numbers",code:"\n      import { distinctUntilChanged } from 'rxjs/operators';\n      import { of } from 'rxjs/observable/of';\n\n      of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)\n       .pipe(distinctUntilChanged())\n       .subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/poxayavuge/embed?js,console"}},{name:"An example using a compare function",code:"\n      import { distinctUntilChanged } from 'rxjs/operators';\n      import { of } from 'rxjs/observable/of';\n\n       of(\n         { age: 4, name: 'Foo'},\n         { age: 7, name: 'Bar'},\n         { age: 5, name: 'Foo'},\n         { age: 6, name: 'Foo'}\n        )\n        .pipe(distinctUntilChanged((p, q) => p.name === q.name))\n        .subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/duhexuhoxo/embed?js,console"}}],relatedOperators:[],additionalResources:[]},{name:"filter",operatorType:"filtering",signature:"public filter(predicate: function(value: T, index: number): boolean, thisArg: any): Observable",parameters:[{name:"predicate",type:"function(value: T, index: number): boolean",attribute:"",description:"A function that evaluates each value emitted by the source Observable.\n         If it returns true, the value is emitted, if false the value is not passed to the output Observable.\n        The index parameter is the number i for the i-th source emission that has happened since the subscription,\n         starting from the number 0."},{name:"thisArg",type:"any",attribute:"optional",description:"An optional argument to determine the value of this in the predicate function."}],marbleUrl:"http://reactivex.io/rxjs/img/filter.png",shortDescription:{description:"Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.",extras:[{type:"Tip",text:'\n        Like\n        <a\n         target="_blank"\n         href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter">\n          Array.prototype.filter()\n        </a>,\n        it only emits a value from the source if it passes a criterion function.\n        '}]},walkthrough:{description:'\n      <p>\n        Similar to the well-known <span class="markdown-code">Array.prototype.filter</span>\n         method, this operator takes values from the source Observable,\n         passes them through a predicate function and only emits those values that yielded true.\n      </p>\n    '},examples:[{name:"Filter for even numbers",code:"\n      import { filter } from 'rxjs/operators';\n      import { from } from 'rxjs/observable/from';\n\n      //emit (1,2,3,4,5)\n      const source = from([1, 2, 3, 4, 5]);\n      //filter out non-even numbers\n      const example = source.pipe(filter(num => num % 2 === 0));\n      //output: \"Even number: 2\", \"Even number: 4\"\n      const subscribe = example.subscribe(val => console.log('Even number: ' + val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/vafogoluye/1/embed?js,console"}}],relatedOperators:["distinct","distinctUntilChanged","distinctUntilKeyChanged","ignoreElements","partition","skip"]},{name:"first",operatorType:"filtering",signature:"public first(predicate: function(value: T, index: number, source: Observable<T>):\n   boolean, resultSelector: function(value: T, index: number): R, defaultValue: R): Observable<T | R>",parameters:[{name:"predicate",type:"function(value: T, index: number, source: Observable<T>): boolean\t",attribute:"optional",description:"An optional function called with each item to test for condition matching."},{name:"resultSelector",type:"function(value: T, index: number): R",attribute:"optional",description:'\n       A function to produce the value on the output Observable based on the\n        values and the indices of the source Observable. The arguments passed to this function are:\n       value: the value that was emitted on the source.\n       index: the "index" of the value from the source.\n       '},{name:"defaultValue",type:"R",attribute:"optional",description:"The default value emitted in case no valid value was found on the source."}],marbleUrl:"http://reactivex.io/rxjs/img/first.png",shortDescription:{description:"Emits only the first value (or the first value that meets some condition) emitted by the source Observable.",extras:[{type:"Tip",text:"Emits only the first value. Or emits only the first value that passes some test."}]},walkthrough:{description:'\n     <p>\n      If called with no arguments, first emits the first value of the source Observable, then completes.\n     </p>\n     <p>\n      If called with a <span class="markdown-code">predicate</span> function,\n      <span class="markdown-code>first</code> emits the first value of the source that matches the specified condition.\n     </p>\n     <p>\n       It may also take a <span class="markdown-code">resultSelector</span> function to produce the output value from the input value,\n       and a <span class="markdown-code">defaultValue</span> to emit in case the source completes before it is able to emit a valid value.\n     </p>\n     <p>\n       Throws an error if defaultValue was not provided and a matching element is not found.\n     </p>\n     '},examples:[{name:"Emit only the X postition of first click that happens on the DOM",code:"\n        import { first } from 'rxjs/operators';\n        import { from } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const result = clicks.pipe(first());\n        result.subscribe(x => console.log(x));\n       ",externalLink:{platform:"JSBin",url:"http://jsbin.com/zixuweg/1/embed?html,js,console,output"}},{name:"Emits only the X postition of first click that happens on a DIV",code:"\n        import { first } from 'rxjs/operators';\n        import { from } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const result = clicks.pipe(first(ev => ev.target.tagName === 'DIV'));\n        result.subscribe(x => console.log(x));\n       ",externalLink:{platform:"JSBin",url:"http://jsbin.com/yuwebew/1/embed?js,console,output"}}]},{name:"ignoreElements",operatorType:"filtering"},{name:"last",operatorType:"filtering",signature:"public last(predicate: function): Observable",useInteractiveMarbles:!0,parameters:[{name:"predicate",type:"function",attribute:"",description:"The condition any source emitted item has to satisfy."}],marbleUrl:"http://reactivex.io/rxjs/img/last.png",shortDescription:{description:"Emits only the last value emitted by the source Observable."},walkthrough:{description:'<p>\n      <span class="markdown-code">last</span> Returns an Observable that emits only the last item emitted by the source Observable.\n    </p>\n    <p>\n       It optionally takes a predicate function as a parameter,\n       in which case, rather than emitting the last item from the source Observable,\n       the resulting Observable will emit the last item from the source Observable that satisfies the predicate.\n    </p>'},examples:[{name:"Get the last number that is divisible by 3",code:"\n      import { last } from 'rxjs/operators';\n      import { range } from 'rxjs/observable/range';\n\n      const range = range(1, 10);\n      const last = range.pipe(last(x => x % 3 === 0));\n      last.subscribe(x => console.log(x));\n      // Logs below values\n      // 9\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/reqacoselu/embed?html,js,console"}}],relatedOperators:["takeLast","first"]},{name:"sample",operatorType:"filtering",signature:"public sample(notifier: Observable<any>): Observable<T>",parameters:[{name:"notifier",type:"Observable<any>",attribute:"",description:"The Observable to use for sampling the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/sample.png",shortDescription:{description:"Emits the most recently emitted value from the source Observable whenever another Observable, the notifier, emits.",extras:[{type:"Tip",text:"It's like sampleTime, but samples whenever the notifier Observable emits something."}]},walkthrough:{description:"\n      <p>\n       Whenever the notifier Observable emits a value or completes,\n       sample looks at the source Observable and emits whichever value it has most recently emitted since the previous sampling,\n       unless the source has not emitted anything since the previous sampling.\n      </p>\n      <p>\n       The notifier is subscribed to as soon as the output Observable is subscribed.\n      </p>\n    "},examples:[{name:"On every click, sample the value from source every 2 seconds",code:"\n        import { sample } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n\n        //emit value every 1s\n        const source = interval(1000);\n        //sample last emitted value from source every 2s\n        const example = source.pipe(sample(interval(2000)));\n        //output: 2..4..6..8..\n        const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/gemebopifu/1/embed?js,console"}}],relatedOperators:["audit","debounce","sampleTime","throttle"]},{name:"single",operatorType:"filtering",signature:"public single(predicate: Function): Observable<T>",parameters:[{name:"predicate",type:"Function",attribute:"",description:"A predicate function to evaluate items emitted by the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/single.png",shortDescription:{description:"Returns an Observable that emits the single item emitted by the source Observable\n       that matches a specified predicate, if that Observable emits one such item.\n       If the source Observable emits more than one such item or no such items, notify of an IllegalArgumentException\n       or NoSuchElementException respectively."},examples:[{name:"Emit first number passing predicate",code:"\n      import { single } from 'rxjs/operators';\n      import { from } from 'rxjs/observable/from';\n\n      //emit (1,2,3,4,5)\n      const source = from([1, 2, 3, 4, 5]);\n      //emit one item that matches predicate\n      const example = source.pipe(single(val => val === 4));\n      //output: 4\n      const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/solecibuza/embed?js,console"}}]},{name:"skip",operatorType:"filtering",signature:"public skip(count: Number): Observable",parameters:[{name:"count",type:"Number",attribute:"",description:"Returns an Observable that skips the first count items emitted by the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/skip.png",shortDescription:{description:"Returns an Observable that skips the first count items emitted by the source Observable."},examples:[{name:"Skipping values before emission",code:"\n        import { skip } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n\n        //emit every 1s\n        const source = interval(1000);\n        //skip the first 5 emitted values\n        const example = source.pipe(skip(5));\n        //output: 5...6...7...8........\n        const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/hacepudabi/1/embed?js,console"}}]},{name:"skipUntil",operatorType:"filtering",signature:"public skipUntil(notifier: Observable): Observable<T>",parameters:[{name:"notifier",type:"Observable",attribute:"",description:"The second Observable that has to emit an item before\n       the source Observable's elements begin to be mirrored by the resulting Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/skipUntil.png",shortDescription:{description:"Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item."},examples:[{name:"Emits every 1s after 5 seconds",code:"\n        import { skipUntil } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n        import { timer } from 'rxjs/observable/timer';\n\n        //emit every 1s\n        const source = interval(1000);\n        //skip emitted values from source until inner observable emits (6s)\n        const example = source.pipe(skipUntil(timer(6000)));\n        //output: 5...6...7...8........\n        const subscribe = example.subscribe(val => console.log(val));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/tapizososu/embed?js,console,output"}}]},{name:"skipWhile",operatorType:"filtering",signature:"\n    public skipWhile(predicate: Function): Observable\n  ",parameters:[{name:"predicate",type:"Function",attribute:"",description:"A function to test each item emitted from the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/skipWhile.png",shortDescription:{description:"\n    Returns an Observable that skips all items emitted by the source Observable\n    as long as a specified condition holds true, but emits all further source items as soon as the condition becomes false.\n  "},examples:[{name:"",code:"\n      import { range } from 'rxjs/observable/range';\n      import { skipWhile } from 'rxjs/operators';\n\n      const source = range(1, 20);\n      // skips all values until the first divisible by 7, then emit all values from then on\n      const example = source.pipe(\n                              skipWhile(val => val % 7 !== 0)\n                            );\n      const subscribe = example.subscribe(val => console.log(val));\n\n     // Ouput\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/qupucehelo/embed?js,console,output"}}]},{name:"take",operatorType:"filtering",signature:"public take(count: number): Observable<T>",useInteractiveMarbles:!0,parameters:[{name:"count",type:"number",attribute:"",description:"The maximum number of next values to emit."}],marbleUrl:"http://reactivex.io/rxjs/img/take.png",shortDescription:{description:"Emits only the first count values emitted by the source Observable.",extras:[{type:"Tip",text:"Takes the first count values from the source, then completes."}]},walkthrough:{description:'<p>\n      <span class="markdown-code">take</span> returns an Observable that emits only the first count values emitted by the source Observable.\n    </p>\n    <p>\n      If the source emits fewer than count values then all of its values are emitted.\n      After that, it completes, regardless if the source completes.\n    </p>'},examples:[{name:"Take the first 5 seconds of an infinite 1-second interval Observable",code:"\n        import { take } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n\n        const interval = interval(1000);\n        const five = interval.pipe(take(5));\n        five.subscribe(x => console.log(x));\n        // Logs below values\n        // 0\n        // 1\n        // 2\n        // 3\n        // 4\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/yujema/embed?html,js,console"}}],relatedOperators:["takeLast","takeUntil","takeWhile","skip"]},{name:"takeUntil",operatorType:"filtering",signature:"public takeUntil(notifier: Observable): Observable<T>",useInteractiveMarbles:!0,parameters:[{name:"notifier",type:"Observable",attribute:"",description:"The Observable whose first emitted value will cause the output Observable of takeUntil\n      to stop emitting values from the source Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/takeUntil.png",shortDescription:{description:"Emits the values emitted by the source Observable until a notifier Observable emits a value.",extras:[{type:"Tip",text:"\n          Lets values pass until a second Observable, notifier, emits something. Then, it completes.\n        "}]},walkthrough:{description:"\n    <p>\n      <code>takeUntil</code> subscribes and begins mirroring the source Observable.\n    </p>\n    <p>\n      It also monitors a second Observable, notifier that you provide.\n      If the notifier emits a value or a complete notification, the output Observable stops mirroring the source Observable and completes.\n    </p>\n\n    "},examples:[{name:"Tick every second until the first click happens",code:"\n        import { takeUntil } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const interval = interval(1000);\n        const clicks = fromEvent(document, 'click');\n        const result = interval.pipe(takeUntil(clicks));\n        result.subscribe(x => console.log(x));\n\n        // Logs the number of seconds since the stream started.\n        // Stream will end as soon as a click action is performed\n        // anywhere in the document\n\n        // 1\n        // 2\n        // 3\n        // ...\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/rujeci/embed?html,js,console,output"}}],relatedOperators:["take","takeLast","takeWhile","skip"]},{name:"takeWhile",operatorType:"filtering",signature:"public takeWhile(predicate: function(value: T, index: number): boolean): Observable",parameters:[{name:"predicate",type:"function(value: T, index: number): boolean",attribute:"",description:"\n        A function that evaluates a value emitted by the source Observable and returns a boolean.\n        Also takes the (zero-based) index as the second argument.\n      "}],marbleUrl:"http://reactivex.io/rxjs/img/takeWhile.png",shortDescription:{description:"\n    Emits values emitted by the source Observable so long as each value satisfies the given predicate,\n     and then completes as soon as this predicate is not satisfied.\n    "},walkthrough:{description:'\n    <p>\n      <span class="markdown-code">takeWhile</span> subscribes and begins mirroring the source Observable.\n    </p>\n    <p>\n      Each value emitted on the source is given to the predicate function which returns a boolean,\n      representing a condition to be satisfied by the source values.\n    </p>\n    <p>\n      The output Observable emits the source values until such time as the predicate returns false,\n      at which point <span class="takeWhile"> stops mirroring the source Observable and completes the output Observable.\n    </p>\n    '},examples:[{name:"\n      Emit click events only while the clientX property is greater than 100\n      ",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { takeWhile } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click');\n      const result = clicks.pipe(\n                        takeWhile(ev => ev.clientX > 100)\n                     );\n      result.subscribe(x => console.log(x));\n\n      // clientX value is logged while its > 100\n      529\n      436\n      214\n      161\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/lasosinudi/embed?js,console,output"}}],relatedOperators:["take","takeLast","takeUntil","skip"]},{name:"throttle",operatorType:"filtering",signature:"public throttle(durationSelector: function(value: T): SubscribableOrPromise): Observable<T>",parameters:[{name:"durationSelector",type:"function(value: T): SubscribableOrPromise",attribute:"",description:"\n        A function that receives a value from the source Observable, for computing the silencing duration for each source value,\n         returned as an Observable or a Promise.\n      "}],marbleUrl:"http://reactivex.io/rxjs/img/throttle.png",shortDescription:{description:"Emits a value from the source Observable, then ignores subsequent source values for a duration\n     determined by another Observable, then repeats this process.",extras:[{type:"Tip",text:"It's like throttleTime, but the silencing duration is determined by a second Observable."}]},walkthrough:{description:'\n    <p>\n      <code>throttle</code> emits the source Observable values on the output Observable when its internal timer is disabled,\n       and ignores source values when the timer is enabled. Initially, the timer is disabled.\n    </p>\n    <p>\n      As soon as the first source value arrives, it is forwarded to the output Observable,\n      and then the timer is enabled by calling the durationSelector function with the source value,\n      which returns the "duration" Observable.\n    </p>\n    <p>\n      When the duration Observable emits a value or completes,\n      the timer is disabled, and this process repeats for the next source value.\n    </p>\n    '},examples:[{name:"Emit X position of mouse click at a rate of at most one click per second",code:"\n        import { throttle } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const result = clicks.pipe(throttle(ev => interval(1000)));\n        result.subscribe(x => console.log(x.clientX));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/wojifil/embed?js,console,output"}}],relatedOperators:["audit","debounce","delayWhen","sample","throttleTime"]},{name:"throttleTime",operatorType:"filtering",signature:"public throttleTime(duration: number, scheduler: Scheduler): Observable<T>",parameters:[{name:"duration",type:"number",attribute:"",description:"Time to wait before emitting another value after emitting the last value,\n         measured in milliseconds or the time unit determined internally by the optional scheduler."},{name:"scheduler",type:"Scheduler",attribute:"optional default:sync",description:"The IScheduler to use for managing the timers that handle the sampling."}],marbleUrl:"http://reactivex.io/rxjs/img/throttleTime.png",shortDescription:{description:"Emits a value from the source Observable,\n        then ignores subsequent source values for duration milliseconds, then repeats this process.",extras:[{type:"Tip",text:"\n          Lets a value pass, then ignores source values for the next duration milliseconds.\n        "}]},walkthrough:{description:"\n    <p>\n      throttleTime emits the source Observable values on the output Observable when its internal timer is disabled,\n       and ignores source values when the timer is enabled. Initially, the timer is disabled.\n    </p>\n    <p>\n      As soon as the first source value arrives, it is forwarded to the output Observable, and then the timer is enabled.\n    </p>\n    <p>\n      After duration milliseconds (or the time unit determined internally by the optional scheduler) has passed, the timer is disabled,\n      and this process repeats for the next source value. Optionally takes a IScheduler for managing timers.\n    </p>\n    "},examples:[{name:"Emit X position of mouse clicks at a rate of at most one click per second",code:"\n        import { throttleTime } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const result = clicks.pipe(throttleTime(1000));\n        result.subscribe(x => console.log(x.clientX));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/nefefeb/embed?js,console,output"}}],relatedOperators:["auditTime","debounceTime","delay","sampleTime","throttle"]}],[{name:"multicast",operatorType:"multicasting"},{name:"publish",operatorType:"multicasting"},{name:"share",operatorType:"multicasting"}],[{name:"buffer",operatorType:"transformation",signature:"public buffer(closingNotifier: Observable): Observable",useInteractiveMarbles:!0,parameters:[{name:"closingNotifier",type:"Observable",attribute:"",description:"An Observable that signals the buffer to be emitted on the output Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/buffer.png",shortDescription:{description:'\n      Buffers the source Observable values until <span class="markdown-code">closingNotifier</span>\n      emits.\n    '},walkthrough:{description:'\n      <p>\n        Buffers the incoming Observable values until the given\n        <span class="markdown-code">closingNotifier</span> Observable emits a value, at which point\n        it emits the buffer on the output Observable and starts a new buffer internally,\n        awaiting the next time <span class="markdown-code">closingNotifier</span> emits.\n      </p>\n    '},examples:[{name:"On every click, emit array of most recent interval events",code:"\n        import { buffer } from 'rxjs/operators';\n        import { interval } from 'rxjs/observable/interval';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const interval = interval(1000);\n        const buffered = interval.pipe(buffer(clicks));\n        buffered.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/xetemuteho/embed?js,console,output"}}],relatedOperators:["bufferCount","bufferTime","bufferToggle","bufferWhen","window"],additionalResources:[]},{name:"bufferCount",operatorType:"transformation",signature:" bufferCount(bufferSize: number, startBufferEvery: number): Observable",parameters:[{name:"bufferSize",type:"number",attribute:"",description:"The maximum size of the buffer emitted."},{name:"startBufferEvery",type:"number",attribute:"optional",description:"Interval at which to start a new buffer. For example if startBufferEvery is 2,\n      then a new buffer will be started on every other value from the source.\n      A new buffer is started at the beginning of the source by default."}],marbleUrl:"http://reactivex.io/rxjs/img/bufferCount.png",shortDescription:{description:'\n    Buffers the source Observable values until the size hits the maximum <span class="markdown-code">bufferSize</span> given.\n    <span class="informal">\n    Collects values from the past as an array,\n    and emits that array only when its size reaches <span class="markdown-code">bufferSize</span>.\n    </span>'},walkthrough:{description:'\n    Buffers a number of values from the source Observable\n    by <span class="markdown-code">bufferSize</span> then emits the buffer and clears it,\n     and starts a new buffer each <span class="markdown-code">startBufferEvery</span> values.\n    If <span class="markdown-code">startBufferEvery</span> is not provided or is null,\n    then new buffers are started immediately at the start of the source and when each buffer closes and is emitted.\n    '},examples:[{name:"Every two clicks, emit those two click events as an array",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { bufferCount } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const buffered = clicks.pipe(\n        bufferCount(2)\n      );\n      buffered.subscribe(x => console.log(x));\n      /*\n      Example console output:\n\n      [[object Object] {\n        x: 235,\n        y: 140\n      }, [object Object] {\n        x: 63,\n        y: 45\n      }]\n\n      [[object Object] {\n        x: 199,\n        y: 74\n      }, [object Object] {\n        x: 133,\n        y: 181\n      }]\n\n      [[object Object] {\n        x: 343,\n        y: 174\n      }, [object Object] {\n        x: 274,\n        y: 82\n      }]\n      */\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/ceripaf/8/embed?js,console,output"}},{name:"On every click, emit the last two click events as an array",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { bufferCount } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const buffered = clicks.pipe(\n        bufferCount(2, 1)\n      );\n      buffered.subscribe(x => console.log(x));\n      /*\n      Example console output:\n\n      [[object Object] {\n        x: 241,\n        y: 118\n      }, [object Object] {\n        x: 176,\n        y: 183\n      }]\n\n      [[object Object] {\n        x: 176,\n        y: 183\n      }, [object Object] {\n        x: 276,\n        y: 239\n      }]\n\n      [[object Object] {\n        x: 276,\n        y: 239\n      }, [object Object] {\n        x: 341,\n        y: 90\n      }]\n\n      [[object Object] {\n        x: 341,\n        y: 90\n      }, [object Object] {\n        x: 140,\n        y: 99\n      }]\n\n      [[object Object] {\n        x: 140,\n        y: 99\n      }, [object Object] {\n        x: 253,\n        y: 335\n      }]\n      */\n",externalLink:{platform:"JSBin",url:"http://jsbin.com/cenuwip/6/embed?js,console,output"}}],relatedOperators:["buffer","bufferTime","bufferToggle","bufferWhen","pairwise","windowCount"]},{name:"bufferTime",operatorType:"transformation",signature:"bufferTime(\n    bufferTimeSpan: number,\n    bufferCreationInterval: number,\n    maxBufferSize: number,\n    scheduler: Scheduler): Observable",parameters:[{name:"bufferTimeSpan",type:"number",attribute:"",description:"The amount of time (in milliseconds) to fill each buffer array."},{name:"bufferCreationInterval",type:"number",attribute:"optional",description:"The interval (in milliseconds) at which to start new buffers."},{name:"maxBufferSize",type:"number",attribute:"optional",description:"The maximum amount of items per buffer."},{name:"scheduler",type:"Scheduler",attribute:"optional\n                  default: async",description:"The scheduler on which to schedule the intervals that determine buffer boundaries."}],marbleUrl:"http://reactivex.io/rxjs/img/bufferTime.png",shortDescription:{description:'Buffers the source Observable values for a specific time period.\n\n    <span class="informal">Collects values from the past as an array, and emits those arrays periodically in time.</span>'},walkthrough:{description:'\n    Buffers values from the source for a specific time duration <span class="markdown-code">bufferTimeSpan</span>.\n    It emits and resets the buffer every <span class="markdown-code">bufferTimeSpan</span> milliseconds,\n    unless the optional argument <span class="markdown-code">bufferCreationInterval</span> is given.\n    If <span class="markdown-code">bufferCreationInterval</span> is given,\n     this operator emits the buffered values and re-opens the buffer every <span class="markdown-code">bufferCreationInterval</span>\n      milliseconds and closes (no further values are buffered) the buffer every\n      <span class="markdown-code">bufferTimeSpan</span> milliseconds.\n    When the optional argument <span class="markdown-code">maxBufferSize</span> is specified,\n     the buffer will be closed either after <span class="markdown-code">bufferTimeSpan</span> milliseconds\n      or when it contains <span class="markdown-code">maxBufferSize</span> elements.'},examples:[{name:"After every two and a half seconds, emit an array of the click events during that timeframe",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { bufferTime } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const buffered = clicks.pipe(\n        bufferTime(2500)\n      );\n      buffered.subscribe(x => console.log(x));\n\n      /*\n      Example console output\n\n      []\n\n      [[object Object] {\n        x: 150,\n        y: 139\n      }, [object Object] {\n        x: 150,\n        y: 139\n      }, [object Object] {\n        x: 150,\n        y: 139\n      }, [object Object] {\n        x: 150,\n        y: 139\n      }]\n\n      [[object Object] {\n        x: 150,\n        y: 139\n      }]\n\n      [[object Object] {\n        x: 150,\n        y: 137\n      }, [object Object] {\n        x: 150,\n        y: 137\n      }]\n\n      []\n      */\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/fuqewiy/7/embed?js,console,output"}},{name:"Every five seconds, emit the click events from a window of the last two seconds",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { bufferTime } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const buffered = clicks.pipe(\n        bufferTime(2000, 5000)\n      );\n      buffered.subscribe(x => console.log(x));\n\n      /*\n      Example console output:\n\n      []\n\n      []\n\n      [[object Object] {\n        x: 159,\n        y: 140\n      }, [object Object] {\n        x: 159,\n        y: 140\n      }]\n\n      [[object Object] {\n        x: 161,\n        y: 140\n      }, [object Object] {\n        x: 161,\n        y: 140\n      }, [object Object] {\n        x: 161,\n        y: 140\n      }, [object Object] {\n        x: 161,\n        y: 140\n      }, [object Object] {\n        x: 161,\n        y: 140\n      }, [object Object] {\n        x: 161,\n        y: 140\n      }]\n\n      []\n      */\n",externalLink:{platform:"JSBin",url:"http://jsbin.com/xohupot/6/embed?js,console,output"}}],relatedOperators:["buffer","bufferCount","bufferToggle","bufferWhen","windowTime"]},{name:"bufferToggle",operatorType:"transformation",signature:"bufferToggle(\n    openings: SubscribableOrPromise,\n    closingSelector: (value) => SubscribableOrPromise): Observable",parameters:[{name:"openings",type:"SubscribableOrPromise",attribute:"",description:"A Subscribable or Promise of notifications to start new buffers."},{name:"closingSelector",type:"(value) => SubscribableOrPromise",attribute:"",description:"A function that takes the value emitted by the openings observable\n      and returns a Subscribable or Promise, which, when it emits, signals that the associated buffer should be emitted and cleared."}],marbleUrl:"http://reactivex.io/rxjs/img/bufferToggle.png",shortDescription:{description:'\n    Buffers the source Observable values starting from an emission from <span class="markdown-code">openings</span>\n    and ending when the output of <span class="markdown-code">closingSelector</span> emits.\n    <span class="informal">\n    Collects values from the past as an array. Starts collecting only when <span class="markdown-code">openings</span> emits,\n    and calls the <span class="markdown-code">closingSelector</span> function\n    to get an Observable that tells when to close the buffer.</span>'},walkthrough:{description:'\n    Buffers values from the source by opening the buffer via signals from an Observable\n    provided to <span class="markdown-code">openings</span>,\n    and closing and sending the buffers when a Subscribable or Promise\n    returned by the <span class="markdown-code">closingSelector</span> function emits.\n    '},examples:[{name:"Every other second, emit the click events from the next 500ms",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { interval } from 'rxjs/observable/interval';\n      import { empty } from 'rxjs/observable/empty';\n      import { bufferToggle } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const openings = interval(1000);\n      const buffered = clicks.pipe(\n        bufferToggle(openings, i => i % 2 ? interval(500) : empty())\n      );\n      buffered.subscribe(x => console.log(x));\n      /*\n      Expected console output:\n\n      []\n\n      [[object Object] {\n        x: 156,\n        y: 165\n      }, [object Object] {\n        x: 156,\n        y: 165\n      }, [object Object] {\n        x: 156,\n        y: 165\n      }]\n\n      []\n\n      []\n      */\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/nuriyod/6/embed?js,console,output"}},{name:'Start buffering all the click events when you press the "S" key and close the buffer when you press the "E" key',code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { filter, bufferToggle } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const keyUp = fromEvent(document,'keyup');\n      const openings = keyUp.pipe(filter(e => e.key === 's'));\n      const closing = keyUp.pipe(filter(e => e.key === 'e'));\n      const buffered = clicks.pipe(\n        bufferToggle(openings, _ => closing)\n      );\n      buffered.subscribe(x => console.log(x));\n\n      /*\n      Expected console output:\n\n      [[object Object] {\n        x: 147,\n        y: 135\n      }, [object Object] {\n        x: 147,\n        y: 135\n      }, [object Object] {\n        x: 144,\n        y: 135\n      }, [object Object] {\n        x: 144,\n        y: 135\n      }, [object Object] {\n        x: 144,\n        y: 135\n      }]\n\n      [[object Object] {\n        x: 144,\n        y: 135\n      }, [object Object] {\n        x: 144,\n        y: 135\n      }]\n\n      [[object Object] {\n        x: 143,\n        y: 136\n      }]\n      */\n",externalLink:{platform:"JSBin",url:"http://jsbin.com/vurobel/12/embed?js,console,output"}}],relatedOperators:["buffer","bufferCount","bufferTime","bufferWhen","windowToggle"]},{name:"bufferWhen",operatorType:"transformation",signature:"bufferWhen(closingSelector: () => Observable): Observable",parameters:[{name:"closingSelector",type:"() => Observable",attribute:"",description:"A function that takes no arguments and returns an Observable that signals buffer closure."}],marbleUrl:"http://reactivex.io/rxjs/img/bufferWhen.png",shortDescription:{description:'Buffers the source Observable values, using a factory function of closing Observables\n     to determine when to close, emit, and reset the buffer.\n    <span class="informal">Collects values from the past as an array.\n     When it starts collecting values, it calls a function that returns an Observable that tells\n      when to close the buffer and restart collecting.</span>'},walkthrough:{description:'\n    Opens a buffer immediately, then closes the buffer when the observable returned by calling\n    <span class="markdown-code">closingSelector</span> function emits a value.\n     When it closes the buffer, it immediately opens a new buffer and repeats the process.'},examples:[{name:"Emit an array of the last clicks every [1-5] random seconds",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { interval  } from 'rxjs/observable/interval';\n      import { bufferWhen } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const buffered = clicks.pipe(\n        bufferWhen(() => interval(1000 + Math.random() * 4000))\n      )\n      buffered.subscribe(x => console.log(x));\n\n      /*\n      Example console output:\n\n      []\n\n      []\n\n      [[object Object] {\n        x: 87,\n        y: 222\n      }, [object Object] {\n        x: 87,\n        y: 222\n      }, [object Object] {\n        x: 100,\n        y: 228\n      }, [object Object] {\n        x: 151,\n        y: 296\n      }]\n\n      [[object Object] {\n        x: 130,\n        y: 368\n      }, [object Object] {\n        x: 132,\n        y: 368\n      }, [object Object] {\n        x: 227,\n        y: 212\n      }, [object Object] {\n        x: 189,\n        y: 321\n      }, [object Object] {\n        x: 160,\n        y: 411\n      }, [object Object] {\n        x: 160,\n        y: 411\n      }, [object Object] {\n        x: 155,\n        y: 366\n      }]\n\n      []\n      */\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/jemeron/9/embed?js,console,output"}},{name:"Buffer all the click events until you press the Enter key",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { filter, bufferWhen } from 'rxjs/operators';\n\n      const enterKeys = fromEvent(document,'keyup')\n                          .pipe(filter(e => e.key === \"Enter\"));\n      const clicks = fromEvent(document, 'click', e => ({x: e.clientX, y: e.clientY}));\n      const buffered = clicks.pipe(\n        bufferWhen(() => enterKeys)\n      );\n      buffered.subscribe(x => console.log(x));\n\n      /*\n      Example console output:\n\n      [[object Object] {\n        x: 186,\n        y: 136\n      }, [object Object] {\n        x: 188,\n        y: 136\n      }, [object Object] {\n        x: 189,\n        y: 136\n      }, [object Object] {\n        x: 189,\n        y: 136\n      }, [object Object] {\n        x: 192,\n        y: 136\n      }]\n\n      [[object Object] {\n        x: 196,\n        y: 135\n      }, [object Object] {\n        x: 196,\n        y: 135\n      }]\n\n      [[object Object] {\n        x: 198,\n        y: 125\n      }]\n\n      [[object Object] {\n        x: 196,\n        y: 135\n      }, [object Object] {\n        x: 196,\n        y: 135\n      }]\n\n      []\n      */\n",externalLink:{platform:"JSBin",url:"http://jsbin.com/tuvesok/5/embed?js,console,output"}}],relatedOperators:["buffer","bufferCount","bufferTime","bufferToggle","windowWhen"]},{name:"concatMap",operatorType:"transformation"},{name:"expand",operatorType:"transformation"},{name:"groupBy",operatorType:"transformation",signature:"\n    public groupBy(keySelector: (value: T) => K,\n                   elementSelector?: ((value: T) => R) | void,\n                   durationSelector?: (grouped: GroupedObservable<K, R>) => Observable<any>,\n                   subjectSelector?: () => Subject<R>)\n          : Observable<any>): OperatorFunction<T, GroupedObservable<K, R>>",parameters:[{name:"keySelector",type:"(value: T) => K",attribute:"",description:"A function that extracts the key used for grouping for each item."},{name:"elementSelector",type:"((value: T) => R) | void",attribute:"optional",description:"A function that extracts the emitted element for each item. Default is identity function."},{name:"durationSelector",type:"(grouped: GroupedObservable<K, R>) => Observable<any>",attribute:"optional",description:"A function that returns an Observable to determine how long each group should exist."},{name:"subjectSelector",type:"() => Subject<R>",attribute:"optional",description:""}],marbleUrl:"http://reactivex.io/rxjs/img/groupBy.png",shortDescription:{description:"\n      Group, according to a specified key, elements from items emitted by an Observable,\n      and emit these grouped items as GroupedObservables, one GroupedObservable per group.\n    ",extras:[]},walkthrough:{description:"\n    <p>When the Observable emits an item, a key is computed for this item with the keySelector function.</p>\n\n    <p>If a GroupedObservable for this key exists, this GroupedObservable emits. Elsewhere, a new\n    GroupedObservable for this key is created and emits.</p>\n\n    <p>A GroupedObservable represents values belonging to the same group represented by a common key.\n    The common key is available as the key field of a GroupedObservable instance.</p>\n\n    <p>The elements emitted by GroupedObservables are by default the items emitted by the Observable,\n    or elements returned by the elementSelector function.\n    "},examples:[{name:"Group objects by id and return as array",code:"\n          import { mergeMap, groupBy } from 'rxjs/operators';\n          import { of } from 'rxjs/observable/of';\n\n          interface Obj {\n            id: number;\n            name: string;\n          }\n\n          of<Obj>({id: 1, name: 'aze1'},\n                              {id: 2, name: 'sf2'},\n                              {id: 2, name: 'dg2'},\n                              {id: 1, name: 'erg1'},\n                              {id: 1, name: 'df1'},\n                              {id: 2, name: 'sfqfb2'},\n                              {id: 3, name: 'qfs3'},\n                              {id: 2, name: 'qsgqsfg2'})\n          .pipe(\n            groupBy(p => p.id)\n            mergeMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))\n          )\n          .subscribe(p => console.log(p));\n        /*\n          Output:\n          [ { id: 1, name: 'aze1' },\n            { id: 1, name: 'erg1' },\n            { id: 1, name: 'df1' } ]\n\n          [ { id: 2, name: 'sf2' },\n            { id: 2, name: 'dg2' },\n            { id: 2, name: 'sfqfb2' },\n            { id: 2, name: 'qsgqsfg2' } ]\n\n          [ { id: 3, name: 'qfs3' } ]\n        */\n        ",externalLink:{platform:"JSBin",url:"http://jsbin.com/linekelumo/1/embed?js,console"}},{name:"Pivot data on the id field",code:"\n          import { mergeMap, groupBy, map } from 'rxjs/operators';\n          import { of } from 'rxjs/observable/of';\n\n          interface Obj {\n            id: number;\n            name: string;\n          }\n            of<Obj>({id: 1, name: 'aze1'},\n                                {id: 2, name: 'sf2'},\n                                {id: 2, name: 'dg2'},\n                                {id: 1, name: 'erg1'},\n                                {id: 1, name: 'df1'},\n                                {id: 2, name: 'sfqfb2'},\n                                {id: 3, name: 'qfs1'},\n                                {id: 2, name: 'qsgqsfg2'})\n            .pipe(\n              groupBy(p => p.id, p => p.name)\n              mergeMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], [\"\" + group$.key]))\n              map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))\n            )\n            .subscribe(p => console.log(p));\n          /*\n            Output:\n            { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }\n\n            { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }\n\n            { id: 3, values: [ 'qfs1' ] }\n          */\n        ",externalLink:{platform:"JSBin",url:"http://jsbin.com/racikizeji/embed?js,console"}}],relatedOperators:[],additionalResources:[]},{name:"map",operatorType:"transformation",signature:"public map(project: Function, thisArg: any): Observable",parameters:[{name:"project",type:"(value: T, index: number) => R",attribute:"",description:"The function to apply to each 'value' emitted by the source Observable. The 'index' parameter is the number 'i'\n        for the i-th emission that has happened since the subscription, starting from the number '0'."},{name:"thisArg",type:"any",attribute:"optional",description:"An optional argument to define what this is in the 'project' function."}],marbleUrl:"http://reactivex.io/rxjs/img/map.png",shortDescription:{description:'\n      Applies a given <span class="markdown-code">project</span> function to each value emitted by the source\n      Observable, and emits the resulting values as an Observable.\n    ',extras:[]},walkthrough:{description:'\n      <p>\n        Similar to the well known\n        <a\n          href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map"\n          target="_blank"\n          class="markdown-code">\n          Array.prototype.map\n        </a> function,\n        this operator applies a projection to each value and emits that projection in the output\n        Observable.\n      </p>\n    '},examples:[{name:"Map every click to the clientX position of that click",code:"\n        import { map } from 'rxjs/operators';\n        import { of } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const positions = clicks.pipe(map(ev => ev.clientX));\n        positions.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/detidogile/embed?js,console,output"}}],relatedOperators:["mapTo","pluck"],additionalResources:[]},{name:"mapTo",operatorType:"transformation",signature:"public mapTo(value: any): Observable",parameters:[{name:"value",type:"any",attribute:"",description:"The value to map each source value to."}],useInteractiveMarbles:!0,marbleUrl:"http://reactivex.io/rxjs/img/mapTo.png",shortDescription:{description:"Emits the given constant value on the output Observable every time the source Observable emits a value."},walkthrough:{description:"<p>\n        Takes a constant\n        <code>value</code> as argument,\n        and emits that whenever the source Observable emits a value.\n        In other words, ignores the actual source value,\n        and simply uses the emission moment to know when to emit the given\n       <code>value</code>.\n       <p>"},examples:[{name:"Map every click to the string 'Hi'",code:"\n      import { fromEvent } from 'rxjs/observable/fromEvent';\n      import { mapTo } from 'rxjs/operators';\n\n      const clicks = fromEvent(document, 'click');\n      const greetings = clicks.pipe(mapTo('Hi');\n      greetings.subscribe(x => console.log(x));\n      /*\n        Example console output:\n        Hi\n      */\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/seyibe/embed?js,console,output"}}],relatedOperators:["map"],additionalResources:[]},{name:"mergeMap",operatorType:"transformation",signature:"public mergeMap(project: Function, resultSelector?: Function, concurrent?: number): Observable",useInteractiveMarbles:!0,parameters:[{name:"project",type:"(value: T, index: number) => ObservableInput",attribute:"",description:"A function that, when applied to an item emitted by the source Observable, returns\n      an Observable."},{name:"resultSelector",type:"(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => any",attribute:"optional",description:"A function to produce the value on the output Observable based on the values and the indices\n        of the source (outer) emission and the inner Observable emission. The arguments passed to this function are:\n        'outerValue': the value that came from the source,\n        'innerValue': the value that came from the projected Observable,\n        'outerIndex': the \"index\" of the value that came from the source,\n        'innerIndex': the \"index\" of the value from the projected Observable."},{name:"concurrent",type:"number",attribute:"optional",description:"Maximum number of input Observables being subscribed to concurrently."}],marbleUrl:"http://reactivex.io/rxjs/img/mergeMap.png",shortDescription:{description:"\n      Projects each source value to an Observable which is merged in the output Observable.\n    ",extras:[]},walkthrough:{description:"\n      <p>\n        Returns an Observable that emits items based on applying a function that you supply\n        to each item emitted by the source Observable, where that function returns an Observable,\n        and then merging those resulting Observables and emitting the results of this merger.\n      </p>\n    "},examples:[{name:"Map and flatten each letter to an Observable ticking every 1 second",code:'\n        import { of } from \'rxjs/observable/of\';\n        import { interval } from \'rxjs/observable/interval\';\n        import { mergeMap, map } from \'rxjs/operators\';\n\n        const letters = of(\'a\', \'b\', \'c\');\n        const result = letters.pipe(\n                            mergeMap(x => {\n                              return interval(1000).pipe(map(i => x+i));\n                            })\n                       );\n        result.subscribe(x => console.log(x));\n\n        // Output\n        "a0"\n        "b0"\n        "c0"\n        "a1"\n        "b1"\n        "c1"\n        "a2"\n        "b2"\n        "c2"\n      ',externalLink:{platform:"JSBin",url:"http://jsbin.com/pekelowibe/embed?js,console"}}],relatedOperators:["concatMap","exhaustmap","merge","mergeAll","mergeMapTo","mergeScan","switchMap"],additionalResources:[]},{name:"partition",operatorType:"transformation",signature:"public partition(predicate: function(value: T, index: number): boolean, thisArg: any): [Observable<T>, Observable<T>]",marbleUrl:"http://reactivex.io/rxjs/img/partition.png",parameters:[{name:"predicate",type:"function(value: T, index: number): boolean",attribute:"",description:"A function that evaluates each value emitted by the source Observable. If it returns 'true', the value is emitted on the\n      first Observable in the returned array, if 'false' the value is emitted on the second Observable in the array. The 'index' parameter\n      is the number 'i' for the i-th source emission that has happened since the subscription, starting from the number '0'."},{name:"thisArg",type:"any",attribute:"optional",description:"An optional argument to determine the value of 'this' in the predicate function."}],shortDescription:{description:"Splits the source Observable into two, one with values that satisfy a predicate, and another with values\n      that don't satisfy the predicate.",extras:[{type:"Tip",text:'\n        It\'s like <a href="#/operators/filter" class="markdown-code">filter</a>, but returns two Observables: one like the output of\n        <a href="#/operators/filter" class="markdown-code">filter</a>, and the other with values that did not pass the condition.\n        '}]},walkthrough:{description:'\n      <p>\n        <span class="markdown-code">partition</span> outputs an array with two Observables that partition the values from the source\n        Observable through the given <span class="markdown-code">predicate</span> function. The first Observable in that array emits\n        source values for which the predicate argument returns true. The second Observable emits source values for which the predicate\n        returns false. The first behaves like <a href="#/operators/filter" class="markdown-code">filter</a> and the second behaves like\n        <a href="#/operators/filter" class="markdown-code">filter</a> with the predicate negated.\n      </p>\n    '},examples:[{name:"Partition click events into those on DIV elements and those elsewhere",code:"\n        import { partition } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const parts = clicks.pipe(partition(ev => ev.target.tagName === 'DIV'));\n        const clicksOnDivs = parts[0];\n        const clicksElsewhere = parts[1];\n        clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));\n        clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/vekisov/embed?js,console,output"}}],relatedOperators:["filter"],additionalResources:[]},{name:"pluck",operatorType:"transformation",signature:"public pluck(properties: ...string): Observable",marbleUrl:"http://reactivex.io/rxjs/img/pluck.png",parameters:[{name:"properties",type:"...string",attribute:"",description:"\n        The nested properties to 'pluck' from each source value (an object).\n      "}],shortDescription:{description:"Maps each source value (an object) to its specified nested property.",extras:[{type:"Tip",text:'\n          Like <a href="#/operators/map" class="markdown-code">map</a>, but meant\n          only for picking one of the nested properties of every emitted object.\n        '}]},walkthrough:{description:'\n      <p>\n        Given a list of strings describing a path to an object property, retrieves\n        the value of a specified nested property from all values in the source Observable.\n        If a property can\'t be resolved, it will return <span class="markdown-code">undefined</span>\n        for that value.\n      </p>\n    '},examples:[{name:"Map every every click to the tagName of the clicked target element",code:"\n        import { pluck } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const tagNames = clicks.pipe(pluck('target', 'tagName'));\n        tagNames.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/vucuca/embed?js,console,output"}}],relatedOperators:["map"],additionalResources:[]},{name:"scan",operatorType:"transformation",signature:"public scan(accumulator: Function, seed: any): Observable",parameters:[{name:"accumulator",type:"(acc: R, value: T, index: number) => R",attribute:"",description:"The accumulator function called on each source value."},{name:"seed",type:"T|R",attribute:"optional",description:"The initial accumulation value."}],useInteractiveMarbles:!0,marbleUrl:"http://reactivex.io/rxjs/img/scan.png",shortDescription:{description:'\n          Applies an <span class="markdown-code">accumulator</span> function over the source Observable, and\n          returns each intermediate result, with an optional <span class="markdown-code">seed</span> value.\n      ',extras:[]},walkthrough:{description:'\n          <p>\n              Combines together all values emitted on the source, using an accumulator\n              function that knows how to join a new source value into the accumulation from\n              the past. Is similar to <a href="/operators/reduce" class="markdown-code">reduce</a>, but emits the\n              intermediate accumulations.\n          </p>\n          <p>\n              Returns an Observable that applies a specified <span class="markdown-code">accumulator</span> function to each\n              item emitted by the source Observable. If a <span class="markdown-code">seed</span> value is specified, then\n              that value will be used as the initial value for the accumulator. If no seed value is specified,\n              the first item of the source is used as the seed.\n          </p>\n      '},examples:[{name:"Count the number of click events",code:"\n        import { mapTo, scan } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        let clicks = fromEvent(document, 'click');\n        let ones = clicks.pipe(mapTo(1));\n        let seed = 0;\n        let count = ones.pipe(scan((acc, one) => acc + one, seed));\n        count.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/qemuzufofo/embed?js,console,output"}}],relatedOperators:["expand","mergeScan","reduce"],additionalResources:[]},{name:"switchMap",operatorType:"transformation",signature:"switchMap(project: (value: T, index: number) => ObservableInput<I>,\n  resultSelector: (outerValue: T, innerValue: I, outerIndex: number, innerIndex: number) => R): Observable",parameters:[{name:"project",type:"function(value: T, index: number): ObservableInput",attribute:"",description:"A function that, when applied to an item emitted by the source\n       Observable, returns an Observable."},{name:"resultSelector",type:"function(outerValue: T, innerValue: I, outerIndex: number, innerIndex: number): any",attribute:"optional",description:"A function to produce the value on the output Observable based on the values\n      and the indices of the source (outer) emission and the inner Observable\n      emission. The arguments passed to this function are:\n      - 'outerValue': the value that came from the source.\n      - 'innerValue': the value that came from the projected Observable.\n      - 'outerIndex': the \"index\" of the value that came from the source.\n      - 'innerIndex': the \"index\" of the value from the projected Observable."}],marbleUrl:"http://reactivex.io/rxjs/img/switchMap.png",shortDescription:{description:'Projects each source value to an Observable which is merged in the output\n    Observable, emitting values only from the most recently projected Observable.\n\n    <span class="informal">Maps each value to an Observable, then flattens all of\n    these inner Observables using <code>switch</code>.</span>'},walkthrough:{description:'Returns an Observable that emits items based on applying a function that you\n    supply to each item emitted by the source Observable, where that function\n    returns an (so-called "inner") Observable. Each time it observes one of these\n    inner Observables, the output Observable begins emitting the items emitted by\n    that inner Observable. When a new inner Observable is emitted, <code>switchMap</code>\n    stops emitting items from the earlier-emitted inner Observable and begins\n    emitting items from the new one. It continues to behave like this for\n    subsequent inner Observables.'},examples:[{name:"Rerun an interval Observable on every click even",code:"\n          import { switchMap } from 'rxjs/operators';\n          import { fromEvent } from 'rxjs/observable/fromEvent';\n          import { interval } from 'rxjs/observable/interval';\n\n          const clicks = fromEvent(document, 'click');\n          const result = clicks.pipe(\n            switchMap((ev) => interval(1000))\n          );\n          result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/yehawof/edit?js,console,output"}}],relatedOperators:["concatMap","exhaustMap","mergeMap","switch","switchMapTo"]},{name:"window",operatorType:"transformation",signature:"public window(windowBoundaries: Observable<any>): Observable<Observable<T>>",parameters:[{name:"windowBoundaries",type:"Observable<any>",attribute:"",description:"An Observable that completes the previous window and starts a new window."}],marbleUrl:"http://reactivex.io/rxjs/img/window.png",shortDescription:{description:'\n      Branch out the source Observable values as a nested Observable\n      whenever <span class="markdown-code">windowBoundaries</span> emits.\n    ',extras:[{type:"Tip",text:'\n          It\'s like  <a href="#/operators/buffer" class="markdown-code">buffer</a>,\n          but emits a nested Observable instead of an array.\n        '}]},walkthrough:{description:'\n      <p>\n        Returns an Observable that emits windows of items it collects\n        from the source Observable. The output Observable emits connected,\n        non-overlapping windows. It emits the current window and opens a new\n        one whenever the Observable <span class="markdown-code">windowBoundaries</span>\n        emits an item. Because each window is an Observable, the output is a higher-order Observable.\n      </p>\n    '},examples:[{name:"In every window of 1 second each, emit at most 2 click events",code:"\n        import { window, take, map, mergeAll } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n        import { interval } from 'rxjs/observable/interval';\n\n        const clicks = fromEvent(document, 'click');\n        const interval = interval(1000);\n        const result = clicks.pipe(\n          window(interval)\n          // each window has at most 2 emissions\n          map(win => win.pipe(take(2)))\n          // flatten the Observable-of-Observables\n          mergeAll()\n        );\n        result.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/racefub/embed?js,console,output"}}],relatedOperators:["windowCount","windowTime","windowToggle","windowWhen","buffer"]},{name:"windowCount",operatorType:"transformation"},{name:"windowToggle",operatorType:"transformation"},{name:"windowWhen",operatorType:"transformation"}],[{name:"delay",operatorType:"utility",signature:"public delay(delay: number | Date, scheduler: Scheduler): Observable",parameters:[{name:"delay",type:"number | Date",attribute:"",description:"The delay duration in milliseconds (a number) or a Date until which the\n      emission of the source items is delayed."},{name:"scheduer",type:"Scheduler",attribute:"",description:"The IScheduler to use for managing the timers that handle the time-shift for each item."}],useInteractiveMarbles:!0,marbleUrl:"http://reactivex.io/rxjs/img/delay.png",shortDescription:{description:"\n      Delays the emission of items from the source Observable by a given timeout or until a given Date.\n    ",extras:[]},walkthrough:{description:"\n      <p>\n        If the delay argument is a Number, this operator time shifts the source Observable by that amount\n        of time expressed in milliseconds. The relative time intervale between the values are preserved.\n      </p>\n      <p>\n        If the delay argument is a Date, this operator time shifts the start of the Observable execution\n        until the given date occurs.\n      </p>\n    "},examples:[{name:"Delay each click by one second",code:"\n        import { delay, mapTo } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click').pipe(mapTo('click'));\n        const delayedClicks = clicks.pipe(delay(1000));\n        delayedClicks.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/howeziyoma/embed?js,console,output"}},{name:"Delay all clicks until a future date happens",code:"\n        import { delay } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const date = new Date('March 15, 2050 12:00:00');\n        const delayedClicks = clicks.pipe(delay(date));\n        delayedClicks.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/cozogifayu/embed?js,console,output"}}],relatedOperators:["debounceTime","delayWhen"],additionalResources:[]},{name:"delayWhen",operatorType:"utility"},{name:"dematerialize",operatorType:"utility"},{name:"do",operatorType:"utility",signature:"public do(nextOrObserver: Observer | function, error: function, complete: function): Observable",parameters:[{name:"nextOrObserver",type:"Observer|function",attribute:"optional",description:"A normal Observer object or a callback for `next`."},{name:"error",type:"function",attribute:"optional",description:"Callback for errors in the source."},{name:"complete",type:"function",attribute:"optional",description:"Callback for the completion of the source."}],marbleUrl:"http://reactivex.io/rxjs/img/do.png",shortDescription:{description:'Perform a side effect for every emission on the source Observable, but return\n      an Observable that is identical to the source.\n      <span class="informal">Intercepts each emission on the source and runs a\n      function, but returns an output which is identical to the source as long as errors don\'t\n      occur.</span>'},walkthrough:{description:'\n      <p>Returns a mirrored Observable of the source Observable,\n      but modified so that the provided Observer is called to perform a side effect for every\n      value, error, and completion emitted by the source. Any errors that are thrown in\n      the aforementioned Observer or handlers are safely sent down the error path\n      of the output Observable.\n      </p>\n      <p>\n      This operator is useful for debugging your Observables for the correct values\n      or performing other side effects.\n      </p>\n      <p>\n      Note: this is different to a <span class="markdown-code">subscribe</span> on the Observable. If the Observable\n      returned by <span class="markdown-code">do</span> is not subscribed, the side effects specified by the\n      Observer will never happen. <span class="markdown-code">do</span> therefore simply spies on existing\n      execution, it does not trigger an execution to happen like <span class="markdown-code">subscribe</span> does.</p>\n    '},examples:[{name:"Map every click to the clientX position of that click, while also logging the click event",code:"\n        import { tap, map } from 'rxjs/operators';\n        import { fromEvent } from 'rxjs/observable/fromEvent';\n\n        const clicks = fromEvent(document, 'click');\n        const positions = clicks.pipe(\n          tap(ev => console.log(ev.type))\n          map(ev => ev.clientX)\n        )\n        positions.subscribe(x => console.log(x));\n      ",externalLink:{platform:"JSBin",url:"http://jsbin.com/pijosapixu/embed?js,console,output"}}],relatedOperators:["map","subscribe"]},{name:"let",operatorType:"utility",signature:"public let(fun: function): Observable,",parameters:[{name:"fun",type:"function",attribute:"",description:"Selector function which can use the source sequence\n    as many times as needed, without sharing subscriptions to the source sequence."}],shortDescription:{description:"Returns an observable sequence that is the result of invoking the selector on the source sequence,\n    without sharing subscriptions. This operator allows for a fluent style of writing queries that use the same\n    sequence multiple times. There is an alias of letBind for browsers older than IE 9."},additionalResources:[{url:"https://www.learnrxjs.io/operators/utility/let.html",description:"several examples of using the let operator",author:"btroncone"}],examples:[{name:"calls concat as part of a pipeline",code:"\n      import { range } from 'rxjs/observable/range';\n\n    const obs = range(1, 3);\n\n    const source = obs.let((o) => o.concat(o));\n\n    const subscription = source.subscribe(\n    (x) => {\n        console.log('Next: ' + x);\n    },\n    (err) => {\n        console.log('Error: ' + err);\n    },\n    () => {\n        console.log('Completed');\n    });\n\n    // => Next: 1\n    // => Next: 2\n    // => Next: 3\n    // => Next: 1\n    // => Next: 2\n    // => Next: 3\n    // => Completed\n    ",externalLink:{platform:"JSBin",url:"http://jsbin.com/giwanupiqu/embed?html,js,console"}}]},{name:"toPromise",operatorType:"utility"}]),a=o,s=o,l=function(){},i=t("911F"),c=t("k1En"),u=t("aayJ"),p=t("dYU3"),m=t("UHIZ"),b=t("Un6q"),d=t("ESfO"),h=t("ghl+"),f=t("V8+5"),v=t("8Xfy"),g=t("yxpl"),y=t("vgc3"),x=t("trMa"),O=t("e0rv"),k=t("l6RC"),w=t("3Czw"),j=(t("6Xbx"),t("j5BN")),_=t("OFGE"),T=(t("rT01"),t("CZgk")),E=(t("LaOa"),t("pXwq"),t("5jKg"),t("nihM"),t("Bu8b"),t("0nO6"),t("Lpd/")),S=t("TO51");t("kH4A"),t("2kLc"),t("GZB0"),t("XEj9");var I=t("ka8K"),A=t("Ioj9");t("Rx5t"),t("fNvg"),t("qLnt"),t("3kHg"),t("fAeS");var M=t("SlD5"),L=t("ki1d"),P=t("RXNa"),R=t("R1vt");t("qqDE"),t("5O0w"),t("AP4T");var C=t("jk5D"),B=t("RyBE"),U=t("LT5m");t("eoFs"),t("ZO8H"),t("Ecq+");var D=t("4jwp"),J=t("YXpL"),q=t("GROE"),W=t("Wug/"),N=this&&this.__assign||Object.assign||function(e){for(var n,t=1,r=arguments.length;t<r;t++)for(var o in n=arguments[t])Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o]);return e},F=new r.r("operators"),z=function(){function e(e,n,t){this._breakpointObserver=e,this._operatorMenuService=n,this.operators=t,this._onDestroy=new S.a}return e.prototype.ngOnInit=function(){this.groupedOperators=this.operators.reduce(function(e,n){return N({},e,e[n.operatorType]?((t={})[n.operatorType]=e[n.operatorType].concat([n]),t):((r={})[n.operatorType]=[n],r));var t,r},{}),this.categories=Object.keys(this.groupedOperators)},e.prototype.ngAfterContentInit=function(){var e=this;this._operatorMenuService.menuStatus().pipe(Object(q.a)(function(e){return!!e}),Object(q.e)(this._onDestroy)).subscribe(function(n){return e._sidenav.open()})},Object.defineProperty(e.prototype,"extraSmallScreen",{get:function(){return this._breakpointObserver.isMatched("(max-width: 601px)")},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"smallScreen",{get:function(){return this._breakpointObserver.isMatched("(max-width: 901px)")},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"operatorMenuGap",{get:function(){return this.extraSmallScreen?54:64},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"sidenavMode",{get:function(){return this.smallScreen?"over":"side"},enumerable:!0,configurable:!0}),e.prototype.ngOnDestroy=function(){this._onDestroy.next()},e}(),X=r._7({encapsulation:0,styles:[["[_nghost-%COMP%]{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto;overflow-y:auto;display:-webkit-box;display:-ms-flexbox;display:flex}.operator-container[_ngcontent-%COMP%]{width:100%}.category-subheader[_ngcontent-%COMP%]{text-transform:uppercase;font-weight:600;color:#fff!important;background:#333}.operator-list-sidenav[_ngcontent-%COMP%]{width:300px}.sidenav-toggle[_ngcontent-%COMP%]{position:fixed;right:20px;bottom:10px;z-index:4}"]],data:{animation:[{type:7,name:"growInOut",definitions:[{type:0,name:"in",styles:{type:6,styles:{opacity:1},offset:null},options:void 0},{type:1,expr:"void => *",animation:[{type:6,styles:{opacity:0,transform:"scale3d(.3, .3, .3)"},offset:null},{type:4,styles:null,timings:"150ms ease-in"}],options:null},{type:1,expr:"* => void",animation:[{type:4,styles:{type:6,styles:{opacity:0,transform:"scale3d(.3, .3, .3)"},offset:null},timings:"150ms ease-out"}],options:null}],options:{}}]}});function G(e){return r._32(0,[(e()(),r._9(0,0,null,null,9,"a",[["class","mat-list-item"],["mat-list-item",""],["routerLinkActive","active"]],[[1,"target",0],[8,"href",4]],[[null,"focus"],[null,"blur"],[null,"click"]],function(e,n,t){var o=!0;return"focus"===n&&(o=!1!==r._21(e,1)._handleFocus()&&o),"blur"===n&&(o=!1!==r._21(e,1)._handleBlur()&&o),"click"===n&&(o=!1!==r._21(e,4).onClick(t.button,t.ctrlKey,t.metaKey,t.shiftKey)&&o),o},u.c,u.a)),r._8(1,1097728,null,2,p.b,[r.l,[2,p.f]],null,null),r._28(603979776,4,{_lines:1}),r._28(335544320,5,{_hasAvatar:0}),r._8(4,671744,[[7,4]],0,m.n,[m.l,m.a,b.h],{routerLink:[0,"routerLink"]},null),r._23(5,2),r._8(6,1720320,null,2,m.m,[m.l,r.l,r.G,r.h],{routerLinkActive:[0,"routerLinkActive"]},null),r._28(603979776,6,{links:1}),r._28(603979776,7,{linksWithHrefs:1}),(e()(),r._30(9,2,["\n        ","\n      "]))],function(e,n){e(n,4,0,e(n,5,0,"/operators",n.context.$implicit.name)),e(n,6,0,"active")},function(e,n){e(n,0,0,r._21(n,4).target,r._21(n,4).href),e(n,9,0,n.context.$implicit.name)})}function V(e){return r._32(0,[(e()(),r._9(0,0,null,null,9,"mat-nav-list",[["class","operator-list mat-nav-list"],["role","navigation"]],null,null,null,u.d,u.b)),r._8(1,49152,null,0,p.f,[],null,null),(e()(),r._30(-1,0,["\n      "])),(e()(),r._9(3,0,null,0,2,"h3",[["class","category-subheader mat-subheader"],["mat-subheader",""]],null,null,null,null,null)),r._8(4,16384,null,0,p.e,[],null,null),(e()(),r._30(5,null,["",""])),(e()(),r._30(-1,0,["\n      "])),(e()(),r._4(16777216,null,0,1,null,G)),r._8(8,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,0,["\n    "]))],function(e,n){e(n,8,0,n.component.groupedOperators[n.context.$implicit])},function(e,n){e(n,5,0,n.context.$implicit)})}function $(e){return r._32(0,[(e()(),r._9(0,0,null,null,7,"button",[["class","sidenav-toggle mat-mini-fab"],["color","primary"],["mat-mini-fab",""]],[[24,"@growInOut",0],[8,"disabled",0]],[[null,"click"]],function(e,n,t){var o=!0;return"click"===n&&(o=!1!==r._21(e.parent,7).toggle()&&o),o},d.d,d.b)),r._8(1,180224,null,0,h.b,[r.l,f.a,v.g],{color:[0,"color"]},null),r._8(2,16384,null,0,h.e,[[2,h.b],[8,null]],null,null),(e()(),r._30(-1,0,["\n  "])),(e()(),r._9(4,0,null,0,2,"mat-icon",[["class","mat-icon"],["role","img"]],null,null,null,g.b,g.a)),r._8(5,638976,null,0,y.b,[r.l,y.d,[8,null]],null,null),(e()(),r._30(-1,0,["view_list"])),(e()(),r._30(-1,0,["\n"]))],function(e,n){e(n,1,0,"primary"),e(n,5,0)},function(e,n){e(n,0,0,"in",r._21(n,1).disabled||null)})}function H(e){return r._32(0,[r._28(402653184,1,{_sidenav:0}),(e()(),r._9(1,0,null,null,14,"mat-sidenav-container",[["class","operator-container mat-drawer-container mat-sidenav-container"]],null,null,null,x.c,x.b)),r._8(2,1490944,null,2,O.f,[[2,k.c],r.l,r.B,r.h,O.a],null,null),r._28(603979776,2,{_drawers:1}),r._28(335544320,3,{_content:0}),(e()(),r._30(-1,2,["\n  "])),(e()(),r._9(6,0,null,0,5,"mat-sidenav",[["class","operator-list-sidenav mat-drawer mat-sidenav"],["tabIndex","-1"]],[[40,"@transform",0],[1,"align",0],[2,"mat-drawer-end",null],[2,"mat-drawer-over",null],[2,"mat-drawer-push",null],[2,"mat-drawer-side",null],[2,"mat-sidenav-fixed",null],[4,"top","px"],[4,"bottom","px"]],[["component","@transform.start"],["component","@transform.done"],[null,"keydown"]],function(e,n,t){var o=!0;return"component:@transform.start"===n&&(o=!1!==r._21(e,7)._onAnimationStart(t)&&o),"component:@transform.done"===n&&(o=!1!==r._21(e,7)._onAnimationEnd(t)&&o),"keydown"===n&&(o=!1!==r._21(e,7).handleKeydown(t)&&o),o},x.d,x.a)),r._8(7,3325952,[[2,4],[1,4],["operatorSidenav",4]],0,O.e,[r.l,v.h,v.g,f.a,[2,b.d]],{mode:[0,"mode"],opened:[1,"opened"],fixedInViewport:[2,"fixedInViewport"],fixedTopGap:[3,"fixedTopGap"]},null),(e()(),r._30(-1,0,["\n    "])),(e()(),r._4(16777216,null,0,1,null,V)),r._8(10,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,0,["\n  "])),(e()(),r._30(-1,2,["\n  "])),(e()(),r._9(13,16777216,null,2,1,"router-outlet",[],null,null,null,null,null)),r._8(14,212992,null,0,m.p,[m.b,r.S,r.j,[8,null],r.h],null,null),(e()(),r._30(-1,2,["\n"])),(e()(),r._30(-1,null,["\n"])),(e()(),r._4(16777216,null,null,1,null,$)),r._8(18,16384,null,0,b.k,[r.S,r.P],{ngIf:[0,"ngIf"]},null),(e()(),r._30(-1,null,["\n"]))],function(e,n){var t=n.component;e(n,2,0),e(n,7,0,t.sidenavMode,!t.smallScreen,!0,t.operatorMenuGap),e(n,10,0,t.categories),e(n,14,0),e(n,18,0,t.smallScreen)},function(e,n){e(n,6,0,r._21(n,7)._animationState,null,"end"===r._21(n,7).position,"over"===r._21(n,7).mode,"push"===r._21(n,7).mode,"side"===r._21(n,7).mode,r._21(n,7).fixedInViewport,r._21(n,7).fixedInViewport?r._21(n,7).fixedTopGap:null,r._21(n,7).fixedInViewport?r._21(n,7).fixedBottomGap:null)})}var K=r._5("app-operators",z,function(e){return r._32(0,[(e()(),r._9(0,0,null,null,1,"app-operators",[],null,null,null,H,X)),r._8(1,1294336,null,0,z,[w.a,W.a,F],null,null)],function(e,n){e(n,1,0)},null)},{},{},[]),Y=function(){function e(){this.operatorExtras=[]}return Object.defineProperty(e.prototype,"tips",{get:function(){return this.operatorExtras.filter(function(e){return"Tip"===e.type})},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"warnings",{get:function(){return this.operatorExtras.filter(function(e){return"Warning"===e.type})},enumerable:!0,configurable:!0}),e}(),Z=r._7({encapsulation:0,styles:[[".extra-tip[_ngcontent-%COMP%]{display:-webkit-box;display:-ms-flexbox;display:flex}h3[_ngcontent-%COMP%]{display:inline-block;vertical-align:middle;padding-left:10px}.tip-warning[_ngcontent-%COMP%]{color:#f44336}.tip-info[_ngcontent-%COMP%]{color:#2196f3}"]],data:{}});function Q(e){return r._32(0,[(e()(),r._9(0,0,null,null,7,"div",[["class","extra-tip"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(2,0,null,null,2,"mat-icon",[["class","tip-info mat-icon"],["role","img"]],null,null,null,g.b,g.a)),r._8(3,638976,null,0,y.b,[r.l,y.d,[8,null]],null,null),(e()(),r._30(-1,0,["info"])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(6,0,null,null,0,"h3",[],[[8,"innerHTML",1]],null,null,null,null)),(e()(),r._30(-1,null,["\n"]))],function(e,n){e(n,3,0)},function(e,n){e(n,6,0,n.context.$implicit.text)})}function ee(e){return r._32(0,[(e()(),r._9(0,0,null,null,7,"div",[["class","extra-tip"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(2,0,null,null,2,"mat-icon",[["class","tip-warning mat-icon"],["role","img"]],null,null,null,g.b,g.a)),r._8(3,638976,null,0,y.b,[r.l,y.d,[8,null]],null,null),(e()(),r._30(-1,0,["warning"])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(6,0,null,null,0,"h3",[],[[8,"innerHTML",1]],null,null,null,null)),(e()(),r._30(-1,null,["\n"]))],function(e,n){e(n,3,0)},function(e,n){e(n,6,0,n.context.$implicit.text)})}function ne(e){return r._32(0,[(e()(),r._4(16777216,null,null,1,null,Q)),r._8(1,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,null,["\n"])),(e()(),r._4(16777216,null,null,1,null,ee)),r._8(4,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,null,["\n"]))],function(e,n){var t=n.component;e(n,1,0,t.tips),e(n,4,0,t.warnings)},null)}var te=t("q6td"),re=function(){},oe=r._7({encapsulation:0,styles:[[".parameter-table[_ngcontent-%COMP%]{border-collapse:collapse;border-radius:2px;border-spacing:0;margin:0 0 32px 0;width:100%}.parameter-table[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{background-color:#fafafa;max-width:100px;padding:12px 18px;text-align:left;color:rgba(0,0,0,.692);font-weight:400}.parameter-table[_ngcontent-%COMP%]   td[_ngcontent-%COMP%]{font-weight:400;padding:8px 16px;border:1px solid rgba(0,0,0,.03);background-color:#fff}"]],data:{}});function ae(e){return r._32(0,[(e()(),r._9(0,0,null,null,13,"tr",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(2,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),r._30(3,null,[" "," "])),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(5,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),r._30(6,null,[" "," "])),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(8,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),r._30(9,null,[" "," "])),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(11,0,null,null,1,"td",[],null,null,null,null,null)),(e()(),r._30(12,null,[" "," "])),(e()(),r._30(-1,null,["\n    "]))],null,function(e,n){e(n,3,0,n.context.$implicit.name),e(n,6,0,n.context.$implicit.type),e(n,9,0,n.context.$implicit.attribute),e(n,12,0,n.context.$implicit.description)})}function se(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"h2",[],null,null,null,null,null)),(e()(),r._30(1,null,[" "," "])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n"])),(e()(),r._9(4,0,null,null,29,"table",[["class","parameter-table mat-elevation-z2"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(6,0,null,null,20,"thead",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n    "])),(e()(),r._9(8,0,null,null,17,"tr",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(10,0,null,null,2,"th",[],null,null,null,null,null)),(e()(),r._30(11,null,["",""])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(14,0,null,null,2,"th",[],null,null,null,null,null)),(e()(),r._30(15,null,["",""])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(18,0,null,null,2,"th",[],null,null,null,null,null)),(e()(),r._30(19,null,["",""])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(22,0,null,null,2,"th",[],null,null,null,null,null)),(e()(),r._30(23,null,["",""])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n    "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(28,0,null,null,4,"tbody",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n    "])),(e()(),r._4(16777216,null,null,1,null,ae)),r._8(31,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n"])),(e()(),r._30(-1,null,["\n"]))],function(e,n){e(n,31,0,n.component.operatorParameters)},function(e,n){e(n,1,0,r._31(n,1,0,r._21(n,2).transform("OPERATOR.PARAMETER.TITLE"))),e(n,11,0,r._31(n,11,0,r._21(n,12).transform("OPERATOR.PARAMETER.NAME"))),e(n,15,0,r._31(n,15,0,r._21(n,16).transform("OPERATOR.PARAMETER.TYPE"))),e(n,19,0,r._31(n,19,0,r._21(n,20).transform("OPERATOR.PARAMETER.ATTRIBUTE"))),e(n,23,0,r._31(n,23,0,r._21(n,24).transform("OPERATOR.PARAMETER.DESCRIPTION")))})}var le=t("SMsG"),ie=function(){},ce=r._7({encapsulation:0,styles:[[".operator-name[_ngcontent-%COMP%]{font-size:30px}.signature[_ngcontent-%COMP%]{margin-bottom:24px}mat-toolbar[_ngcontent-%COMP%]{background:#62757f!important;color:#fff;font-weight:400}"]],data:{}});function ue(e){return r._32(0,[(e()(),r._9(0,0,null,null,3,"mat-toolbar",[["class","operator-name mat-toolbar"]],[[2,"mat-toolbar-multiple-rows",null],[2,"mat-toolbar-single-row",null]],null,null,le.b,le.a)),r._8(1,4243456,null,1,J.a,[r.l,f.a],null,null),r._28(603979776,1,{_toolbarRows:1}),(e()(),r._30(3,0,["\n  ","\n"])),(e()(),r._30(-1,null,["\n"])),(e()(),r._9(5,0,null,null,3,"mat-toolbar",[["class","signature mat-toolbar"]],[[2,"mat-toolbar-multiple-rows",null],[2,"mat-toolbar-single-row",null]],null,null,le.b,le.a)),r._8(6,4243456,null,1,J.a,[r.l,f.a],null,null),r._28(603979776,2,{_toolbarRows:1}),(e()(),r._30(8,0,["\n  ","\n"])),(e()(),r._30(-1,null,["\n"]))],null,function(e,n){var t=n.component;e(n,0,0,r._21(n,1)._toolbarRows.length,!r._21(n,1)._toolbarRows.length),e(n,3,0,t.operatorName),e(n,5,0,r._21(n,6)._toolbarRows.length,!r._21(n,6)._toolbarRows.length),e(n,8,0,t.operatorSignature)})}var pe=function(){},me=r._7({encapsulation:0,styles:[[".marble-wrapper[_ngcontent-%COMP%]{background-color:#fff;text-align:center}.marble-diagram[_ngcontent-%COMP%]{max-width:640px}@media screen and (max-width:960px){.marble-diagram[_ngcontent-%COMP%]{max-width:100%}}"]],data:{}});function be(e){return r._32(0,[(e()(),r._9(0,0,null,null,0,"img",[["class","marble-diagram"]],[[8,"src",4],[8,"alt",0]],null,null,null,null))],null,function(e,n){var t=n.component;e(n,0,0,t.url,r._12(1,"Diagram of how ",t.operatorName," works"))})}function de(e){return r._32(0,[(e()(),r._9(0,0,null,null,4,"div",[["class","marble-wrapper mat-elevation-z2"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._4(16777216,null,null,1,null,be)),r._8(3,16384,null,0,b.k,[r.S,r.P],{ngIf:[0,"ngIf"]},null),(e()(),r._30(-1,null,["\n"])),(e()(),r._30(-1,null,["\n"]))],function(e,n){e(n,3,0,n.component.url)},null)}var he=function(){function e(e,n){this.elementRef=e,this.zone=n}return e.prototype.ngAfterViewChecked=function(){if(!this._done&&this.elementRef.nativeElement.innerHTML&&this.elementRef.nativeElement.querySelector){var e=this.elementRef.nativeElement.querySelectorAll("pre");this.zone.runOutsideAngular(function(){for(var n=0,t=e;n<t.length;n++)hljs.highlightBlock(t[n])}),this._done=!0}},e}(),fe=function(){function e(e){this._sanitizer=e}return e.prototype.transform=function(e){return e?this._sanitizer.bypassSecurityTrustResourceUrl(e):e},e}(),ve=function(){return function(){this.copyToClipboard=new r.o}}(),ge=r._7({encapsulation:0,styles:[[".code-block[_ngcontent-%COMP%]{position:relative}.code-block[_ngcontent-%COMP%]   pre[_ngcontent-%COMP%]{margin-top:0;padding-top:0}.example-options[_ngcontent-%COMP%], .menu-button[_ngcontent-%COMP%]{position:absolute;right:0;top:0}.example-header[_ngcontent-%COMP%]{-ms-flex-line-pack:center;align-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:8px 6px 8px 18px;color:rgba(0,0,0,.692);background:#fafafa}.example-header[_ngcontent-%COMP%]   .header-title[_ngcontent-%COMP%]{-webkit-box-flex:1;-ms-flex:1 1 auto;flex:1 1 auto}.code-example[_ngcontent-%COMP%]{margin-bottom:16px}.bin-wrapper[_ngcontent-%COMP%]   iframe[_ngcontent-%COMP%]{border:none;width:100%;height:350px}"]],data:{}});function ye(e){return r._32(0,[(e()(),r._9(0,0,null,null,26,"div",[["appHighlightJs",""],["class","code-example"]],null,null,null,null,null)),r._8(1,8404992,null,0,he,[r.l,r.B],null,null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(3,0,null,null,22,"div",[["class","code-block mat-elevation-z2"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n    "])),(e()(),r._9(5,0,null,null,13,"div",[["class","example-header"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(7,0,null,null,0,"div",[["class","header-title"]],[[8,"innerHTML",1]],null,null,null,null)),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(9,16777216,null,null,8,"button",[["aria-label","Copy"],["class","mat-icon-button"],["mat-icon-button",""],["matTooltip","Copy"],["value","Copy"]],[[8,"disabled",0]],[[null,"click"],[null,"longpress"],[null,"keydown"],[null,"touchend"]],function(e,n,t){var o=!0,a=e.component;return"longpress"===n&&(o=!1!==r._21(e,12).show()&&o),"keydown"===n&&(o=!1!==r._21(e,12)._handleKeydown(t)&&o),"touchend"===n&&(o=!1!==r._21(e,12)._handleTouchend()&&o),"click"===n&&(o=!1!==a.copyToClipboard.emit(e.context.$implicit.code)&&o),o},d.d,d.b)),r._8(10,180224,null,0,h.b,[r.l,f.a,v.g],null,null),r._8(11,16384,null,0,h.d,[],null,null),r._8(12,147456,null,0,C.d,[_.a,r.l,D.d,r.S,r.B,f.a,v.d,v.g,C.b,[2,k.c],[2,C.a]],{message:[0,"message"]},null),(e()(),r._30(-1,0,["\n        "])),(e()(),r._9(14,0,null,0,2,"mat-icon",[["class","mat-icon"],["role","img"]],null,null,null,g.b,g.a)),r._8(15,638976,null,0,y.b,[r.l,y.d,[8,null]],null,null),(e()(),r._30(-1,0,["content_copy"])),(e()(),r._30(-1,0,["\n      "])),(e()(),r._30(-1,null,["\n    "])),(e()(),r._30(-1,null,["\n    "])),(e()(),r._9(20,0,null,null,4,"div",[["class","bin-wrapper"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n      "])),(e()(),r._9(22,0,null,null,1,"iframe",[],[[8,"src",5],[8,"title",0]],null,null,null,null)),r._25(23,1),(e()(),r._30(-1,null,["\n    "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n"]))],function(e,n){e(n,12,0,"Copy"),e(n,15,0)},function(e,n){e(n,7,0,n.context.$implicit.name),e(n,9,0,r._21(n,10).disabled||null),e(n,22,0,r._31(n,22,0,e(n,23,0,r._21(n.parent,0),n.context.$implicit.externalLink.url)),n.context.$implicit.name)})}function xe(e){return r._32(0,[r._24(0,fe,[B.c]),(e()(),r._9(1,0,null,null,2,"h2",[],null,null,null,null,null)),(e()(),r._30(2,null,[" "," "])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n"])),(e()(),r._4(16777216,null,null,1,null,ye)),r._8(6,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,null,["\n"]))],function(e,n){e(n,6,0,n.component.operatorExamples)},function(e,n){e(n,2,0,r._31(n,2,0,r._21(n,3).transform("OPERATOR.EXAMPLES.TITLE")))})}var Oe=function(){},ke=r._7({encapsulation:0,styles:[[""]],data:{}});function we(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"h2",[],null,null,null,null,null)),(e()(),r._30(1,null,[" "," "])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n"])),(e()(),r._9(4,0,null,null,0,"div",[["class","walkthrough-container"]],[[8,"innerHTML",1]],null,null,null,null)),(e()(),r._30(-1,null,["\n"]))],null,function(e,n){var t=n.component;e(n,1,0,r._31(n,1,0,r._21(n,2).transform("OPERATOR.WALKTHROUGH.TITLE"))),e(n,4,0,t.operatorWalkthrough)})}var je=function(){},_e=r._7({encapsulation:0,styles:[[""]],data:{}});function Te(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"h2",[["class","related-operators"]],null,null,null,null,null)),(e()(),r._30(1,null,[" "," "])),r._24(131072,te.i,[te.j,r.h])],null,function(e,n){e(n,1,0,r._31(n,1,0,r._21(n,2).transform("OPERATOR.RELATED_OPERATORS.TITLE")))})}function Ee(e){return r._32(0,[(e()(),r._9(0,0,null,null,6,"li",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n    "])),(e()(),r._9(2,0,null,null,3,"a",[],[[1,"target",0],[8,"href",4]],[[null,"click"]],function(e,n,t){var o=!0;return"click"===n&&(o=!1!==r._21(e,3).onClick(t.button,t.ctrlKey,t.metaKey,t.shiftKey)&&o),o},null,null)),r._8(3,671744,null,0,m.n,[m.l,m.a,b.h],{routerLink:[0,"routerLink"]},null),r._23(4,2),(e()(),r._30(5,null,[" "," "])),(e()(),r._30(-1,null,["\n  "]))],function(e,n){e(n,3,0,e(n,4,0,"/operators",n.context.$implicit))},function(e,n){e(n,2,0,r._21(n,3).target,r._21(n,3).href),e(n,5,0,n.context.$implicit)})}function Se(e){return r._32(0,[(e()(),r._4(16777216,null,null,1,null,Te)),r._8(1,16384,null,0,b.k,[r.S,r.P],{ngIf:[0,"ngIf"]},null),(e()(),r._30(-1,null,["\n"])),(e()(),r._9(3,0,null,null,4,"ul",[["class","section-list"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._4(16777216,null,null,1,null,Ee)),r._8(6,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,null,["\n"])),(e()(),r._30(-1,null,["\n"]))],function(e,n){var t=n.component;e(n,1,0,null==t.relatedOperators?null:t.relatedOperators.length),e(n,6,0,t.relatedOperators)},null)}var Ie=function(){},Ae=r._7({encapsulation:0,styles:[[""]],data:{}});function Me(e){return r._32(0,[(e()(),r._9(0,0,null,null,4,"li",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n    "])),(e()(),r._9(2,0,null,null,1,"a",[["target","_blank"]],[[8,"href",4]],null,null,null,null)),(e()(),r._30(3,null,[" "," "])),(e()(),r._30(-1,null,["\n  "]))],null,function(e,n){e(n,2,0,n.context.$implicit.url),e(n,3,0,n.context.$implicit.description)})}function Le(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"h2",[],null,null,null,null,null)),(e()(),r._30(1,null,[" "," "])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n"])),(e()(),r._9(4,0,null,null,18,"ul",[["class","section-list"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(6,0,null,null,5,"li",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n    "])),(e()(),r._9(8,0,null,null,2,"a",[["target","_blank"]],[[8,"href",4]],null,null,null,null)),(e()(),r._30(9,null,[" "," "])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(13,0,null,null,5,"li",[],null,null,null,null,null)),(e()(),r._30(-1,null,["\n    "])),(e()(),r._9(15,0,null,null,2,"a",[["target","_blank"]],[[8,"href",4]],null,null,null,null)),(e()(),r._30(16,null,[" "," "])),r._24(131072,te.i,[te.j,r.h]),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._4(16777216,null,null,1,null,Me)),r._8(21,802816,null,0,b.j,[r.S,r.P,r.u],{ngForOf:[0,"ngForOf"]},null),(e()(),r._30(-1,null,["\n"])),(e()(),r._30(-1,null,["\n"]))],function(e,n){e(n,21,0,n.component.additionalResources)},function(e,n){var t=n.component;e(n,1,0,r._31(n,1,0,r._21(n,2).transform("OPERATOR.ADDITIONAL_RESOURCES.TITLE"))),e(n,8,0,t.sourceUrl),e(n,9,0,r._31(n,9,0,r._21(n,10).transform("OPERATOR.ADDITIONAL_RESOURCES.SOURCE"))),e(n,15,0,t.specsUrl),e(n,16,0,r._31(n,16,0,r._21(n,17).transform("OPERATOR.ADDITIONAL_RESOURCES.SPECS")))})}var Pe=t("Jaoy"),Re=t("g9BA"),Ce=new r.r("operators"),Be=function(){function e(e,n,t,r,o,a){this._router=e,this._activatedRoute=n,this._seo=t,this._copierService=r,this._snackBar=o,this.operators=a,this.operatorsMap=new Map,this.baseSourceUrl="https://github.com/ReactiveX/rxjs/blob/master/src/internal/operators/",this.baseSpecUrl="http://reactivex.io/rxjs/test-file/spec-js/operators"}return e.prototype.ngOnInit=function(){var e=this;this.operators.forEach(function(n){e.operatorsMap.set(n.name,n)}),this._activatedRoute.params.pipe(Object(q.d)("operator")).subscribe(function(n){e.operatorsMap.has(n)?(e.operator=e.operatorsMap.get(n),e.scrollToTop(),e._seo.setHeaders({title:[e.operator.name,e.operator.operatorType],description:e.operator.shortDescription?e.operator.shortDescription.description:""})):e.notfound()})},e.prototype.scrollToTop=function(){var e=document.querySelector(".mat-drawer-content");e&&(e.scrollTop=0)},e.prototype.copyToClipboard=function(e){this._copierService.copyText(e),this._snackBar.open("The example has been copied to your clipboard!",null,{duration:3e3})},Object.defineProperty(e.prototype,"operatorName",{get:function(){return this.operator.name},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"signature",{get:function(){return this.operator.signature||"Signature Placeholder"},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"marbleUrl",{get:function(){return this.operator.marbleUrl},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"useInteractiveMarbles",{get:function(){return this.operator.useInteractiveMarbles},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"shortDescription",{get:function(){return this.operator.shortDescription&&this.operator.shortDescription.description},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"shortDescriptionExtras",{get:function(){return this.operator.shortDescription&&this.operator.shortDescription.extras},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"walkthrough",{get:function(){return this.operator.walkthrough&&this.operator.walkthrough.description},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"walkthroughExtras",{get:function(){return this.operator.walkthrough&&this.operator.walkthrough.extras},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"parameters",{get:function(){return this.operator.parameters||[]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"examples",{get:function(){return this.operator.examples||[]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"relatedOperators",{get:function(){return this.operator.relatedOperators||[]},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"sourceUrl",{get:function(){return this.baseSourceUrl+"/"+this.operatorName+".ts"},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"specsUrl",{get:function(){return this.baseSpecUrl+"/"+this.operatorName+"-spec.js.html"},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"additionalResources",{get:function(){return this.operator.additionalResources||[]},enumerable:!0,configurable:!0}),e.prototype.notfound=function(){return this._router.navigate(["/operators"]),{}},e}(),Ue=r._7({encapsulation:0,styles:[[".main-operator-container[_ngcontent-%COMP%]{padding:5px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;padding:0 16px;margin-bottom:32px}.short-description[_ngcontent-%COMP%]{margin:16px 0 32px}.margin-bottom-32[_ngcontent-%COMP%]{margin-bottom:32px}.margin-bottom-16[_ngcontent-%COMP%]{margin-bottom:16px}"]],data:{}});function De(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"app-operator-extras",[["class","margin-bottom-16"]],null,null,null,ne,Z)),r._8(1,49152,null,0,Y,[],{operatorExtras:[0,"operatorExtras"]},null),(e()(),r._30(-1,null,["\n  "]))],function(e,n){e(n,1,0,n.component.shortDescriptionExtras)},null)}function Je(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"app-operator-parameters",[],null,null,null,se,oe)),r._8(1,49152,null,0,re,[],{operatorParameters:[0,"operatorParameters"]},null),(e()(),r._30(-1,null,["\n  "]))],function(e,n){e(n,1,0,n.component.parameters)},null)}function qe(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"app-operator-extras",[["class","margin-bottom-16"]],null,null,null,ne,Z)),r._8(1,49152,null,0,Y,[],{operatorExtras:[0,"operatorExtras"]},null),(e()(),r._30(-1,null,["\n  "]))],function(e,n){e(n,1,0,n.component.walkthroughExtras)},null)}function We(e){return r._32(0,[(e()(),r._9(0,0,null,null,2,"app-operator-header",[["class","operator-header"]],[[8,"id",0]],null,null,ue,ce)),r._8(1,49152,null,0,ie,[],{operatorName:[0,"operatorName"],operatorSignature:[1,"operatorSignature"]},null),(e()(),r._30(-1,null,["\n"])),(e()(),r._30(-1,null,["\n"])),(e()(),r._9(4,0,null,null,33,"section",[["class","main-operator-container mat-typography"]],null,null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(6,0,null,null,1,"h3",[["class","short-description"]],[[8,"innerHTML",1]],null,null,null,null)),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._4(16777216,null,null,1,null,De)),r._8(10,16384,null,0,b.k,[r.S,r.P],{ngIf:[0,"ngIf"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(12,0,null,null,2,"app-marble-diagram",[["class","margin-bottom-32"]],null,null,null,de,me)),r._8(13,49152,null,0,pe,[],{operatorName:[0,"operatorName"],useInteractiveMarbles:[1,"useInteractiveMarbles"],url:[2,"url"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(16,0,null,null,2,"app-operator-examples",[["class","margin-bottom-16"]],null,[[null,"copyToClipboard"]],function(e,n,t){var r=!0;return"copyToClipboard"===n&&(r=!1!==e.component.copyToClipboard(t)&&r),r},xe,ge)),r._8(17,49152,null,0,ve,[],{operatorExamples:[0,"operatorExamples"]},{copyToClipboard:"copyToClipboard"}),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._4(16777216,null,null,1,null,Je)),r._8(21,16384,null,0,b.k,[r.S,r.P],{ngIf:[0,"ngIf"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(23,0,null,null,2,"app-operator-walkthrough",[["class","margin-bottom-16"]],null,null,null,we,ke)),r._8(24,49152,null,0,Oe,[],{operatorWalkthrough:[0,"operatorWalkthrough"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._4(16777216,null,null,1,null,qe)),r._8(28,16384,null,0,b.k,[r.S,r.P],{ngIf:[0,"ngIf"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(30,0,null,null,2,"app-related-operators",[],null,null,null,Se,_e)),r._8(31,49152,null,0,je,[],{relatedOperators:[0,"relatedOperators"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n  "])),(e()(),r._9(34,0,null,null,2,"app-additional-resources",[],null,null,null,Le,Ae)),r._8(35,49152,null,0,Ie,[],{additionalResources:[0,"additionalResources"],sourceUrl:[1,"sourceUrl"],specsUrl:[2,"specsUrl"]},null),(e()(),r._30(-1,null,["\n  "])),(e()(),r._30(-1,null,["\n"])),(e()(),r._30(-1,null,["\n"]))],function(e,n){var t=n.component;e(n,1,0,t.operatorName,t.signature),e(n,10,0,t.shortDescriptionExtras),e(n,13,0,t.operatorName,t.useInteractiveMarbles,t.marbleUrl),e(n,17,0,t.examples),e(n,21,0,null==t.parameters?null:t.parameters.length),e(n,24,0,t.walkthrough),e(n,28,0,t.walkthroughExtras),e(n,31,0,t.relatedOperators),e(n,35,0,t.additionalResources,t.sourceUrl,t.specsUrl)},function(e,n){var t=n.component;e(n,0,0,t.operatorName),e(n,6,0,t.shortDescription)})}var Ne=r._5("app-operator",Be,function(e){return r._32(0,[(e()(),r._9(0,0,null,null,1,"app-operator",[],null,null,null,We,Ue)),r._8(1,114688,null,0,Be,[m.l,m.a,Re.a,Pe.a,U.b,Ce],null,null)],function(e,n){e(n,1,0)},null)},{},{},[]),Fe=t("9iV4"),ze=t("zQfh"),Xe=t("FhOc"),Ge=t("hxQ8"),Ve={title:["Operators"],description:"All the RxJS operators..."},$e=function(){};t.d(n,"OperatorsModuleNgFactory",function(){return He});var He=r._6(l,[],function(e){return r._17([r._18(512,r.j,r._2,[[8,[i.a,c.a,c.b,K,Ne]],[3,r.j],r.z]),r._18(4608,b.m,b.l,[r.w,[2,b.s]]),r._18(6144,k.b,null,[b.d]),r._18(4608,k.c,k.c,[[2,k.b]]),r._18(4608,f.a,f.a,[]),r._18(5120,y.d,y.a,[[3,y.d],[2,Fe.c],B.c,[2,b.d]]),r._18(4608,v.i,v.i,[f.a]),r._18(4608,v.h,v.h,[v.i,r.B,b.d]),r._18(136192,v.d,v.b,[[3,v.d],b.d]),r._18(5120,v.l,v.k,[[3,v.l],[2,v.j],b.d]),r._18(5120,v.g,v.e,[[3,v.g],r.B,f.a]),r._18(5120,D.d,D.b,[[3,D.d],r.B,f.a]),r._18(5120,D.g,D.f,[[3,D.g],f.a,r.B]),r._18(4608,_.f,_.f,[D.d,D.g,r.B]),r._18(5120,_.c,_.g,[[3,_.c],b.d]),r._18(4608,_.k,_.k,[D.g,b.d]),r._18(5120,_.d,_.j,[[3,_.d],b.d]),r._18(4608,_.a,_.a,[_.f,_.c,r.j,_.k,_.d,r.g,r.s,r.B,b.d]),r._18(5120,_.h,_.i,[_.a]),r._18(5120,I.b,I.c,[[3,I.b]]),r._18(4608,j.d,j.d,[]),r._18(5120,R.b,R.g,[_.a]),r._18(5120,C.b,C.c,[_.a]),r._18(5120,ze.a,ze.c,[]),r._18(4608,ze.b,ze.b,[ze.a]),r._18(4608,ze.k,ze.k,[r.B,b.d]),r._18(5120,ze.l,ze.j,[[3,ze.l],ze.b,ze.k]),r._18(5120,ze.o,ze.n,[[3,ze.o],ze.k,ze.b]),r._18(4608,w.d,w.d,[f.a]),r._18(135680,w.a,w.a,[w.d,r.B]),r._18(4608,U.b,U.b,[_.a,v.l,r.s,w.a,[3,U.b]]),r._18(512,b.c,b.c,[]),r._18(512,k.a,k.a,[]),r._18(256,j.e,!0,[]),r._18(512,j.k,j.k,[[2,j.e]]),r._18(512,f.b,f.b,[]),r._18(512,J.b,J.b,[]),r._18(512,y.c,y.c,[]),r._18(512,j.u,j.u,[]),r._18(512,v.a,v.a,[]),r._18(512,h.c,h.c,[]),r._18(512,j.l,j.l,[]),r._18(512,j.s,j.s,[]),r._18(512,L.a,L.a,[]),r._18(512,p.c,p.c,[]),r._18(512,T.g,T.g,[]),r._18(512,D.c,D.c,[]),r._18(512,_.e,_.e,[]),r._18(512,O.h,O.h,[]),r._18(512,Xe.c,Xe.c,[]),r._18(512,P.a,P.a,[]),r._18(512,A.g,A.g,[]),r._18(512,E.a,E.a,[]),r._18(512,M.a,M.a,[]),r._18(512,R.e,R.e,[]),r._18(512,C.e,C.e,[]),r._18(512,ze.m,ze.m,[]),r._18(512,ze.e,ze.e,[]),r._18(512,w.c,w.c,[]),r._18(512,U.d,U.d,[]),r._18(512,Ge.a,Ge.a,[]),r._18(512,m.o,m.o,[[2,m.t],[2,m.l]]),r._18(512,$e,$e,[]),r._18(512,te.g,te.g,[]),r._18(512,l,l,[]),r._18(256,O.a,!1,[]),r._18(256,R.a,{overlapTrigger:!0,xPosition:"after",yPosition:"below"},[]),r._18(256,C.a,{showDelay:0,hideDelay:0,touchendHideDelay:1500},[]),r._18(1024,m.j,function(){return[[{path:"",component:z,data:Ve,children:[{path:":operator",component:Be},{path:"",redirectTo:"combineAll",pathMatch:"full"}]}]]},[]),r._18(256,F,a,[]),r._18(256,Ce,s,[])])})}});